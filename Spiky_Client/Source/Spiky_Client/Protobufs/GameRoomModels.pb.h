// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameRoomModels.proto

#ifndef PROTOBUF_GameRoomModels_2eproto__INCLUDED
#define PROTOBUF_GameRoomModels_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "DisableWarnings.pb.h"
#include "MainMenuModels.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_GameRoomModels_2eproto();
void protobuf_AssignDesc_GameRoomModels_2eproto();
void protobuf_ShutdownFile_GameRoomModels_2eproto();

class CreateRoom;
class Room;
class RoomDescribe;
class RoomUpdate;
class RoomsListUpdate;
class SubscribeRoom;
class TeamPlayer;

// ===================================================================

class Room : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Room) */ {
 public:
  Room();
  virtual ~Room();

  Room(const Room& from);

  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Room& default_instance();

  void Swap(Room* other);

  // implements Message ----------------------------------------------

  inline Room* New() const { return New(NULL); }

  Room* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Room& from);
  void MergeFrom(const Room& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Room* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CreateRoom createRoom = 1;
  bool has_createroom() const;
  void clear_createroom();
  static const int kCreateRoomFieldNumber = 1;
  const ::CreateRoom& createroom() const;
  ::CreateRoom* mutable_createroom();
  ::CreateRoom* release_createroom();
  void set_allocated_createroom(::CreateRoom* createroom);

  // optional .RoomsListUpdate roomsListUpdate = 2;
  bool has_roomslistupdate() const;
  void clear_roomslistupdate();
  static const int kRoomsListUpdateFieldNumber = 2;
  const ::RoomsListUpdate& roomslistupdate() const;
  ::RoomsListUpdate* mutable_roomslistupdate();
  ::RoomsListUpdate* release_roomslistupdate();
  void set_allocated_roomslistupdate(::RoomsListUpdate* roomslistupdate);

  // optional .SubscribeRoom subscribeRoom = 3;
  bool has_subscriberoom() const;
  void clear_subscriberoom();
  static const int kSubscribeRoomFieldNumber = 3;
  const ::SubscribeRoom& subscriberoom() const;
  ::SubscribeRoom* mutable_subscriberoom();
  ::SubscribeRoom* release_subscriberoom();
  void set_allocated_subscriberoom(::SubscribeRoom* subscriberoom);

  // optional .RoomUpdate roomUpdate = 4;
  bool has_roomupdate() const;
  void clear_roomupdate();
  static const int kRoomUpdateFieldNumber = 4;
  const ::RoomUpdate& roomupdate() const;
  ::RoomUpdate* mutable_roomupdate();
  ::RoomUpdate* release_roomupdate();
  void set_allocated_roomupdate(::RoomUpdate* roomupdate);

  // optional bool startGame = 5;
  void clear_startgame();
  static const int kStartGameFieldNumber = 5;
  bool startgame() const;
  void set_startgame(bool value);

  // optional string roomName = 6;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 6;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // @@protoc_insertion_point(class_scope:Room)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::CreateRoom* createroom_;
  ::RoomsListUpdate* roomslistupdate_;
  ::SubscribeRoom* subscriberoom_;
  ::RoomUpdate* roomupdate_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  bool startgame_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameRoomModels_2eproto();
  friend void protobuf_AssignDesc_GameRoomModels_2eproto();
  friend void protobuf_ShutdownFile_GameRoomModels_2eproto();

  void InitAsDefaultInstance();
  static Room* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateRoom) */ {
 public:
  CreateRoom();
  virtual ~CreateRoom();

  CreateRoom(const CreateRoom& from);

  inline CreateRoom& operator=(const CreateRoom& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoom& default_instance();

  void Swap(CreateRoom* other);

  // implements Message ----------------------------------------------

  inline CreateRoom* New() const { return New(NULL); }

  CreateRoom* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoom& from);
  void MergeFrom(const CreateRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateRoom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string roomName = 1;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 1;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // optional string mapName = 2;
  void clear_mapname();
  static const int kMapNameFieldNumber = 2;
  const ::std::string& mapname() const;
  void set_mapname(const ::std::string& value);
  void set_mapname(const char* value);
  void set_mapname(const char* value, size_t size);
  ::std::string* mutable_mapname();
  ::std::string* release_mapname();
  void set_allocated_mapname(::std::string* mapname);

  // optional string gameTime = 3;
  void clear_gametime();
  static const int kGameTimeFieldNumber = 3;
  const ::std::string& gametime() const;
  void set_gametime(const ::std::string& value);
  void set_gametime(const char* value);
  void set_gametime(const char* value, size_t size);
  ::std::string* mutable_gametime();
  ::std::string* release_gametime();
  void set_allocated_gametime(::std::string* gametime);

  // optional string maxPlayers = 4;
  void clear_maxplayers();
  static const int kMaxPlayersFieldNumber = 4;
  const ::std::string& maxplayers() const;
  void set_maxplayers(const ::std::string& value);
  void set_maxplayers(const char* value);
  void set_maxplayers(const char* value, size_t size);
  ::std::string* mutable_maxplayers();
  ::std::string* release_maxplayers();
  void set_allocated_maxplayers(::std::string* maxplayers);

  // optional string creator = 5;
  void clear_creator();
  static const int kCreatorFieldNumber = 5;
  const ::std::string& creator() const;
  void set_creator(const ::std::string& value);
  void set_creator(const char* value);
  void set_creator(const char* value, size_t size);
  ::std::string* mutable_creator();
  ::std::string* release_creator();
  void set_allocated_creator(::std::string* creator);

  // @@protoc_insertion_point(class_scope:CreateRoom)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::google::protobuf::internal::ArenaStringPtr mapname_;
  ::google::protobuf::internal::ArenaStringPtr gametime_;
  ::google::protobuf::internal::ArenaStringPtr maxplayers_;
  ::google::protobuf::internal::ArenaStringPtr creator_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameRoomModels_2eproto();
  friend void protobuf_AssignDesc_GameRoomModels_2eproto();
  friend void protobuf_ShutdownFile_GameRoomModels_2eproto();

  void InitAsDefaultInstance();
  static CreateRoom* default_instance_;
};
// -------------------------------------------------------------------

class RoomsListUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoomsListUpdate) */ {
 public:
  RoomsListUpdate();
  virtual ~RoomsListUpdate();

  RoomsListUpdate(const RoomsListUpdate& from);

  inline RoomsListUpdate& operator=(const RoomsListUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomsListUpdate& default_instance();

  void Swap(RoomsListUpdate* other);

  // implements Message ----------------------------------------------

  inline RoomsListUpdate* New() const { return New(NULL); }

  RoomsListUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomsListUpdate& from);
  void MergeFrom(const RoomsListUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoomsListUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool deleteRoom = 1;
  void clear_deleteroom();
  static const int kDeleteRoomFieldNumber = 1;
  bool deleteroom() const;
  void set_deleteroom(bool value);

  // optional bool addRoom = 2;
  void clear_addroom();
  static const int kAddRoomFieldNumber = 2;
  bool addroom() const;
  void set_addroom(bool value);

  // optional string roomName = 3;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 3;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // optional string roomOwner = 4;
  void clear_roomowner();
  static const int kRoomOwnerFieldNumber = 4;
  const ::std::string& roomowner() const;
  void set_roomowner(const ::std::string& value);
  void set_roomowner(const char* value);
  void set_roomowner(const char* value, size_t size);
  ::std::string* mutable_roomowner();
  ::std::string* release_roomowner();
  void set_allocated_roomowner(::std::string* roomowner);

  // @@protoc_insertion_point(class_scope:RoomsListUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::google::protobuf::internal::ArenaStringPtr roomowner_;
  bool deleteroom_;
  bool addroom_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameRoomModels_2eproto();
  friend void protobuf_AssignDesc_GameRoomModels_2eproto();
  friend void protobuf_ShutdownFile_GameRoomModels_2eproto();

  void InitAsDefaultInstance();
  static RoomsListUpdate* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SubscribeRoom) */ {
 public:
  SubscribeRoom();
  virtual ~SubscribeRoom();

  SubscribeRoom(const SubscribeRoom& from);

  inline SubscribeRoom& operator=(const SubscribeRoom& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeRoom& default_instance();

  enum V1Case {
    kSubscribe = 1,
    V1_NOT_SET = 0,
  };

  void Swap(SubscribeRoom* other);

  // implements Message ----------------------------------------------

  inline SubscribeRoom* New() const { return New(NULL); }

  SubscribeRoom* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeRoom& from);
  void MergeFrom(const SubscribeRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscribeRoom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool subscribe = 1;
  private:
  bool has_subscribe() const;
  public:
  void clear_subscribe();
  static const int kSubscribeFieldNumber = 1;
  bool subscribe() const;
  void set_subscribe(bool value);

  // optional string roomName = 2;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 2;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // optional int32 stateCode = 3;
  void clear_statecode();
  static const int kStateCodeFieldNumber = 3;
  ::google::protobuf::int32 statecode() const;
  void set_statecode(::google::protobuf::int32 value);

  // optional .RoomDescribe roomDescribe = 4;
  bool has_roomdescribe() const;
  void clear_roomdescribe();
  static const int kRoomDescribeFieldNumber = 4;
  const ::RoomDescribe& roomdescribe() const;
  ::RoomDescribe* mutable_roomdescribe();
  ::RoomDescribe* release_roomdescribe();
  void set_allocated_roomdescribe(::RoomDescribe* roomdescribe);

  // optional string player = 5;
  void clear_player();
  static const int kPlayerFieldNumber = 5;
  const ::std::string& player() const;
  void set_player(const ::std::string& value);
  void set_player(const char* value);
  void set_player(const char* value, size_t size);
  ::std::string* mutable_player();
  ::std::string* release_player();
  void set_allocated_player(::std::string* player);

  // optional string team = 6;
  void clear_team();
  static const int kTeamFieldNumber = 6;
  const ::std::string& team() const;
  void set_team(const ::std::string& value);
  void set_team(const char* value);
  void set_team(const char* value, size_t size);
  ::std::string* mutable_team();
  ::std::string* release_team();
  void set_allocated_team(::std::string* team);

  V1Case v1_case() const;
  // @@protoc_insertion_point(class_scope:SubscribeRoom)
 private:
  inline void set_has_subscribe();

  inline bool has_v1() const;
  void clear_v1();
  inline void clear_has_v1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::RoomDescribe* roomdescribe_;
  ::google::protobuf::internal::ArenaStringPtr player_;
  ::google::protobuf::internal::ArenaStringPtr team_;
  ::google::protobuf::int32 statecode_;
  union V1Union {
    V1Union() {}
    bool subscribe_;
  } v1_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_GameRoomModels_2eproto();
  friend void protobuf_AssignDesc_GameRoomModels_2eproto();
  friend void protobuf_ShutdownFile_GameRoomModels_2eproto();

  void InitAsDefaultInstance();
  static SubscribeRoom* default_instance_;
};
// -------------------------------------------------------------------

class RoomDescribe : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoomDescribe) */ {
 public:
  RoomDescribe();
  virtual ~RoomDescribe();

  RoomDescribe(const RoomDescribe& from);

  inline RoomDescribe& operator=(const RoomDescribe& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomDescribe& default_instance();

  void Swap(RoomDescribe* other);

  // implements Message ----------------------------------------------

  inline RoomDescribe* New() const { return New(NULL); }

  RoomDescribe* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomDescribe& from);
  void MergeFrom(const RoomDescribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoomDescribe* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TeamPlayer team1 = 1;
  int team1_size() const;
  void clear_team1();
  static const int kTeam1FieldNumber = 1;
  const ::TeamPlayer& team1(int index) const;
  ::TeamPlayer* mutable_team1(int index);
  ::TeamPlayer* add_team1();
  ::google::protobuf::RepeatedPtrField< ::TeamPlayer >*
      mutable_team1();
  const ::google::protobuf::RepeatedPtrField< ::TeamPlayer >&
      team1() const;

  // repeated .TeamPlayer team2 = 2;
  int team2_size() const;
  void clear_team2();
  static const int kTeam2FieldNumber = 2;
  const ::TeamPlayer& team2(int index) const;
  ::TeamPlayer* mutable_team2(int index);
  ::TeamPlayer* add_team2();
  ::google::protobuf::RepeatedPtrField< ::TeamPlayer >*
      mutable_team2();
  const ::google::protobuf::RepeatedPtrField< ::TeamPlayer >&
      team2() const;

  // repeated .TeamPlayer undistributed = 3;
  int undistributed_size() const;
  void clear_undistributed();
  static const int kUndistributedFieldNumber = 3;
  const ::TeamPlayer& undistributed(int index) const;
  ::TeamPlayer* mutable_undistributed(int index);
  ::TeamPlayer* add_undistributed();
  ::google::protobuf::RepeatedPtrField< ::TeamPlayer >*
      mutable_undistributed();
  const ::google::protobuf::RepeatedPtrField< ::TeamPlayer >&
      undistributed() const;

  // optional string roomName = 4;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 4;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // optional string mapName = 5;
  void clear_mapname();
  static const int kMapNameFieldNumber = 5;
  const ::std::string& mapname() const;
  void set_mapname(const ::std::string& value);
  void set_mapname(const char* value);
  void set_mapname(const char* value, size_t size);
  ::std::string* mutable_mapname();
  ::std::string* release_mapname();
  void set_allocated_mapname(::std::string* mapname);

  // optional string gameTime = 6;
  void clear_gametime();
  static const int kGameTimeFieldNumber = 6;
  const ::std::string& gametime() const;
  void set_gametime(const ::std::string& value);
  void set_gametime(const char* value);
  void set_gametime(const char* value, size_t size);
  ::std::string* mutable_gametime();
  ::std::string* release_gametime();
  void set_allocated_gametime(::std::string* gametime);

  // optional string maxPlayers = 7;
  void clear_maxplayers();
  static const int kMaxPlayersFieldNumber = 7;
  const ::std::string& maxplayers() const;
  void set_maxplayers(const ::std::string& value);
  void set_maxplayers(const char* value);
  void set_maxplayers(const char* value, size_t size);
  ::std::string* mutable_maxplayers();
  ::std::string* release_maxplayers();
  void set_allocated_maxplayers(::std::string* maxplayers);

  // optional string creator = 8;
  void clear_creator();
  static const int kCreatorFieldNumber = 8;
  const ::std::string& creator() const;
  void set_creator(const ::std::string& value);
  void set_creator(const char* value);
  void set_creator(const char* value, size_t size);
  ::std::string* mutable_creator();
  ::std::string* release_creator();
  void set_allocated_creator(::std::string* creator);

  // optional .Chat chat = 9;
  bool has_chat() const;
  void clear_chat();
  static const int kChatFieldNumber = 9;
  const ::Chat& chat() const;
  ::Chat* mutable_chat();
  ::Chat* release_chat();
  void set_allocated_chat(::Chat* chat);

  // @@protoc_insertion_point(class_scope:RoomDescribe)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::TeamPlayer > team1_;
  ::google::protobuf::RepeatedPtrField< ::TeamPlayer > team2_;
  ::google::protobuf::RepeatedPtrField< ::TeamPlayer > undistributed_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::google::protobuf::internal::ArenaStringPtr mapname_;
  ::google::protobuf::internal::ArenaStringPtr gametime_;
  ::google::protobuf::internal::ArenaStringPtr maxplayers_;
  ::google::protobuf::internal::ArenaStringPtr creator_;
  ::Chat* chat_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameRoomModels_2eproto();
  friend void protobuf_AssignDesc_GameRoomModels_2eproto();
  friend void protobuf_ShutdownFile_GameRoomModels_2eproto();

  void InitAsDefaultInstance();
  static RoomDescribe* default_instance_;
};
// -------------------------------------------------------------------

class TeamPlayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TeamPlayer) */ {
 public:
  TeamPlayer();
  virtual ~TeamPlayer();

  TeamPlayer(const TeamPlayer& from);

  inline TeamPlayer& operator=(const TeamPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamPlayer& default_instance();

  void Swap(TeamPlayer* other);

  // implements Message ----------------------------------------------

  inline TeamPlayer* New() const { return New(NULL); }

  TeamPlayer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamPlayer& from);
  void MergeFrom(const TeamPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TeamPlayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string player_name = 1;
  void clear_player_name();
  static const int kPlayerNameFieldNumber = 1;
  const ::std::string& player_name() const;
  void set_player_name(const ::std::string& value);
  void set_player_name(const char* value);
  void set_player_name(const char* value, size_t size);
  ::std::string* mutable_player_name();
  ::std::string* release_player_name();
  void set_allocated_player_name(::std::string* player_name);

  // @@protoc_insertion_point(class_scope:TeamPlayer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr player_name_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameRoomModels_2eproto();
  friend void protobuf_AssignDesc_GameRoomModels_2eproto();
  friend void protobuf_ShutdownFile_GameRoomModels_2eproto();

  void InitAsDefaultInstance();
  static TeamPlayer* default_instance_;
};
// -------------------------------------------------------------------

class RoomUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoomUpdate) */ {
 public:
  RoomUpdate();
  virtual ~RoomUpdate();

  RoomUpdate(const RoomUpdate& from);

  inline RoomUpdate& operator=(const RoomUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomUpdate& default_instance();

  void Swap(RoomUpdate* other);

  // implements Message ----------------------------------------------

  inline RoomUpdate* New() const { return New(NULL); }

  RoomUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomUpdate& from);
  void MergeFrom(const RoomUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoomUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .RoomDescribe roomDescribe = 1;
  bool has_roomdescribe() const;
  void clear_roomdescribe();
  static const int kRoomDescribeFieldNumber = 1;
  const ::RoomDescribe& roomdescribe() const;
  ::RoomDescribe* mutable_roomdescribe();
  ::RoomDescribe* release_roomdescribe();
  void set_allocated_roomdescribe(::RoomDescribe* roomdescribe);

  // optional string targetTeam = 2;
  void clear_targetteam();
  static const int kTargetTeamFieldNumber = 2;
  const ::std::string& targetteam() const;
  void set_targetteam(const ::std::string& value);
  void set_targetteam(const char* value);
  void set_targetteam(const char* value, size_t size);
  ::std::string* mutable_targetteam();
  ::std::string* release_targetteam();
  void set_allocated_targetteam(::std::string* targetteam);

  // optional string roomName = 3;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 3;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // @@protoc_insertion_point(class_scope:RoomUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::RoomDescribe* roomdescribe_;
  ::google::protobuf::internal::ArenaStringPtr targetteam_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameRoomModels_2eproto();
  friend void protobuf_AssignDesc_GameRoomModels_2eproto();
  friend void protobuf_ShutdownFile_GameRoomModels_2eproto();

  void InitAsDefaultInstance();
  static RoomUpdate* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Room

// optional .CreateRoom createRoom = 1;
inline bool Room::has_createroom() const {
  return !_is_default_instance_ && createroom_ != NULL;
}
inline void Room::clear_createroom() {
  if (GetArenaNoVirtual() == NULL && createroom_ != NULL) delete createroom_;
  createroom_ = NULL;
}
inline const ::CreateRoom& Room::createroom() const {
  // @@protoc_insertion_point(field_get:Room.createRoom)
  return createroom_ != NULL ? *createroom_ : *default_instance_->createroom_;
}
inline ::CreateRoom* Room::mutable_createroom() {
  
  if (createroom_ == NULL) {
    createroom_ = new ::CreateRoom;
  }
  // @@protoc_insertion_point(field_mutable:Room.createRoom)
  return createroom_;
}
inline ::CreateRoom* Room::release_createroom() {
  // @@protoc_insertion_point(field_release:Room.createRoom)
  
  ::CreateRoom* temp = createroom_;
  createroom_ = NULL;
  return temp;
}
inline void Room::set_allocated_createroom(::CreateRoom* createroom) {
  delete createroom_;
  createroom_ = createroom;
  if (createroom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Room.createRoom)
}

// optional .RoomsListUpdate roomsListUpdate = 2;
inline bool Room::has_roomslistupdate() const {
  return !_is_default_instance_ && roomslistupdate_ != NULL;
}
inline void Room::clear_roomslistupdate() {
  if (GetArenaNoVirtual() == NULL && roomslistupdate_ != NULL) delete roomslistupdate_;
  roomslistupdate_ = NULL;
}
inline const ::RoomsListUpdate& Room::roomslistupdate() const {
  // @@protoc_insertion_point(field_get:Room.roomsListUpdate)
  return roomslistupdate_ != NULL ? *roomslistupdate_ : *default_instance_->roomslistupdate_;
}
inline ::RoomsListUpdate* Room::mutable_roomslistupdate() {
  
  if (roomslistupdate_ == NULL) {
    roomslistupdate_ = new ::RoomsListUpdate;
  }
  // @@protoc_insertion_point(field_mutable:Room.roomsListUpdate)
  return roomslistupdate_;
}
inline ::RoomsListUpdate* Room::release_roomslistupdate() {
  // @@protoc_insertion_point(field_release:Room.roomsListUpdate)
  
  ::RoomsListUpdate* temp = roomslistupdate_;
  roomslistupdate_ = NULL;
  return temp;
}
inline void Room::set_allocated_roomslistupdate(::RoomsListUpdate* roomslistupdate) {
  delete roomslistupdate_;
  roomslistupdate_ = roomslistupdate;
  if (roomslistupdate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Room.roomsListUpdate)
}

// optional .SubscribeRoom subscribeRoom = 3;
inline bool Room::has_subscriberoom() const {
  return !_is_default_instance_ && subscriberoom_ != NULL;
}
inline void Room::clear_subscriberoom() {
  if (GetArenaNoVirtual() == NULL && subscriberoom_ != NULL) delete subscriberoom_;
  subscriberoom_ = NULL;
}
inline const ::SubscribeRoom& Room::subscriberoom() const {
  // @@protoc_insertion_point(field_get:Room.subscribeRoom)
  return subscriberoom_ != NULL ? *subscriberoom_ : *default_instance_->subscriberoom_;
}
inline ::SubscribeRoom* Room::mutable_subscriberoom() {
  
  if (subscriberoom_ == NULL) {
    subscriberoom_ = new ::SubscribeRoom;
  }
  // @@protoc_insertion_point(field_mutable:Room.subscribeRoom)
  return subscriberoom_;
}
inline ::SubscribeRoom* Room::release_subscriberoom() {
  // @@protoc_insertion_point(field_release:Room.subscribeRoom)
  
  ::SubscribeRoom* temp = subscriberoom_;
  subscriberoom_ = NULL;
  return temp;
}
inline void Room::set_allocated_subscriberoom(::SubscribeRoom* subscriberoom) {
  delete subscriberoom_;
  subscriberoom_ = subscriberoom;
  if (subscriberoom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Room.subscribeRoom)
}

// optional .RoomUpdate roomUpdate = 4;
inline bool Room::has_roomupdate() const {
  return !_is_default_instance_ && roomupdate_ != NULL;
}
inline void Room::clear_roomupdate() {
  if (GetArenaNoVirtual() == NULL && roomupdate_ != NULL) delete roomupdate_;
  roomupdate_ = NULL;
}
inline const ::RoomUpdate& Room::roomupdate() const {
  // @@protoc_insertion_point(field_get:Room.roomUpdate)
  return roomupdate_ != NULL ? *roomupdate_ : *default_instance_->roomupdate_;
}
inline ::RoomUpdate* Room::mutable_roomupdate() {
  
  if (roomupdate_ == NULL) {
    roomupdate_ = new ::RoomUpdate;
  }
  // @@protoc_insertion_point(field_mutable:Room.roomUpdate)
  return roomupdate_;
}
inline ::RoomUpdate* Room::release_roomupdate() {
  // @@protoc_insertion_point(field_release:Room.roomUpdate)
  
  ::RoomUpdate* temp = roomupdate_;
  roomupdate_ = NULL;
  return temp;
}
inline void Room::set_allocated_roomupdate(::RoomUpdate* roomupdate) {
  delete roomupdate_;
  roomupdate_ = roomupdate;
  if (roomupdate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Room.roomUpdate)
}

// optional bool startGame = 5;
inline void Room::clear_startgame() {
  startgame_ = false;
}
inline bool Room::startgame() const {
  // @@protoc_insertion_point(field_get:Room.startGame)
  return startgame_;
}
inline void Room::set_startgame(bool value) {
  
  startgame_ = value;
  // @@protoc_insertion_point(field_set:Room.startGame)
}

// optional string roomName = 6;
inline void Room::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Room::roomname() const {
  // @@protoc_insertion_point(field_get:Room.roomName)
  return roomname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Room::set_roomname(const ::std::string& value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Room.roomName)
}
inline void Room::set_roomname(const char* value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Room.roomName)
}
inline void Room::set_roomname(const char* value, size_t size) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Room.roomName)
}
inline ::std::string* Room::mutable_roomname() {
  
  // @@protoc_insertion_point(field_mutable:Room.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Room::release_roomname() {
  // @@protoc_insertion_point(field_release:Room.roomName)
  
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Room::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    
  } else {
    
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:Room.roomName)
}

// -------------------------------------------------------------------

// CreateRoom

// optional string roomName = 1;
inline void CreateRoom::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateRoom::roomname() const {
  // @@protoc_insertion_point(field_get:CreateRoom.roomName)
  return roomname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoom::set_roomname(const ::std::string& value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateRoom.roomName)
}
inline void CreateRoom::set_roomname(const char* value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateRoom.roomName)
}
inline void CreateRoom::set_roomname(const char* value, size_t size) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateRoom.roomName)
}
inline ::std::string* CreateRoom::mutable_roomname() {
  
  // @@protoc_insertion_point(field_mutable:CreateRoom.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoom::release_roomname() {
  // @@protoc_insertion_point(field_release:CreateRoom.roomName)
  
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoom::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    
  } else {
    
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:CreateRoom.roomName)
}

// optional string mapName = 2;
inline void CreateRoom::clear_mapname() {
  mapname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateRoom::mapname() const {
  // @@protoc_insertion_point(field_get:CreateRoom.mapName)
  return mapname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoom::set_mapname(const ::std::string& value) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateRoom.mapName)
}
inline void CreateRoom::set_mapname(const char* value) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateRoom.mapName)
}
inline void CreateRoom::set_mapname(const char* value, size_t size) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateRoom.mapName)
}
inline ::std::string* CreateRoom::mutable_mapname() {
  
  // @@protoc_insertion_point(field_mutable:CreateRoom.mapName)
  return mapname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoom::release_mapname() {
  // @@protoc_insertion_point(field_release:CreateRoom.mapName)
  
  return mapname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoom::set_allocated_mapname(::std::string* mapname) {
  if (mapname != NULL) {
    
  } else {
    
  }
  mapname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapname);
  // @@protoc_insertion_point(field_set_allocated:CreateRoom.mapName)
}

// optional string gameTime = 3;
inline void CreateRoom::clear_gametime() {
  gametime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateRoom::gametime() const {
  // @@protoc_insertion_point(field_get:CreateRoom.gameTime)
  return gametime_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoom::set_gametime(const ::std::string& value) {
  
  gametime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateRoom.gameTime)
}
inline void CreateRoom::set_gametime(const char* value) {
  
  gametime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateRoom.gameTime)
}
inline void CreateRoom::set_gametime(const char* value, size_t size) {
  
  gametime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateRoom.gameTime)
}
inline ::std::string* CreateRoom::mutable_gametime() {
  
  // @@protoc_insertion_point(field_mutable:CreateRoom.gameTime)
  return gametime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoom::release_gametime() {
  // @@protoc_insertion_point(field_release:CreateRoom.gameTime)
  
  return gametime_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoom::set_allocated_gametime(::std::string* gametime) {
  if (gametime != NULL) {
    
  } else {
    
  }
  gametime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gametime);
  // @@protoc_insertion_point(field_set_allocated:CreateRoom.gameTime)
}

// optional string maxPlayers = 4;
inline void CreateRoom::clear_maxplayers() {
  maxplayers_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateRoom::maxplayers() const {
  // @@protoc_insertion_point(field_get:CreateRoom.maxPlayers)
  return maxplayers_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoom::set_maxplayers(const ::std::string& value) {
  
  maxplayers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateRoom.maxPlayers)
}
inline void CreateRoom::set_maxplayers(const char* value) {
  
  maxplayers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateRoom.maxPlayers)
}
inline void CreateRoom::set_maxplayers(const char* value, size_t size) {
  
  maxplayers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateRoom.maxPlayers)
}
inline ::std::string* CreateRoom::mutable_maxplayers() {
  
  // @@protoc_insertion_point(field_mutable:CreateRoom.maxPlayers)
  return maxplayers_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoom::release_maxplayers() {
  // @@protoc_insertion_point(field_release:CreateRoom.maxPlayers)
  
  return maxplayers_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoom::set_allocated_maxplayers(::std::string* maxplayers) {
  if (maxplayers != NULL) {
    
  } else {
    
  }
  maxplayers_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), maxplayers);
  // @@protoc_insertion_point(field_set_allocated:CreateRoom.maxPlayers)
}

// optional string creator = 5;
inline void CreateRoom::clear_creator() {
  creator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateRoom::creator() const {
  // @@protoc_insertion_point(field_get:CreateRoom.creator)
  return creator_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoom::set_creator(const ::std::string& value) {
  
  creator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateRoom.creator)
}
inline void CreateRoom::set_creator(const char* value) {
  
  creator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateRoom.creator)
}
inline void CreateRoom::set_creator(const char* value, size_t size) {
  
  creator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateRoom.creator)
}
inline ::std::string* CreateRoom::mutable_creator() {
  
  // @@protoc_insertion_point(field_mutable:CreateRoom.creator)
  return creator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoom::release_creator() {
  // @@protoc_insertion_point(field_release:CreateRoom.creator)
  
  return creator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoom::set_allocated_creator(::std::string* creator) {
  if (creator != NULL) {
    
  } else {
    
  }
  creator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), creator);
  // @@protoc_insertion_point(field_set_allocated:CreateRoom.creator)
}

// -------------------------------------------------------------------

// RoomsListUpdate

// optional bool deleteRoom = 1;
inline void RoomsListUpdate::clear_deleteroom() {
  deleteroom_ = false;
}
inline bool RoomsListUpdate::deleteroom() const {
  // @@protoc_insertion_point(field_get:RoomsListUpdate.deleteRoom)
  return deleteroom_;
}
inline void RoomsListUpdate::set_deleteroom(bool value) {
  
  deleteroom_ = value;
  // @@protoc_insertion_point(field_set:RoomsListUpdate.deleteRoom)
}

// optional bool addRoom = 2;
inline void RoomsListUpdate::clear_addroom() {
  addroom_ = false;
}
inline bool RoomsListUpdate::addroom() const {
  // @@protoc_insertion_point(field_get:RoomsListUpdate.addRoom)
  return addroom_;
}
inline void RoomsListUpdate::set_addroom(bool value) {
  
  addroom_ = value;
  // @@protoc_insertion_point(field_set:RoomsListUpdate.addRoom)
}

// optional string roomName = 3;
inline void RoomsListUpdate::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoomsListUpdate::roomname() const {
  // @@protoc_insertion_point(field_get:RoomsListUpdate.roomName)
  return roomname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomsListUpdate::set_roomname(const ::std::string& value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomsListUpdate.roomName)
}
inline void RoomsListUpdate::set_roomname(const char* value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomsListUpdate.roomName)
}
inline void RoomsListUpdate::set_roomname(const char* value, size_t size) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomsListUpdate.roomName)
}
inline ::std::string* RoomsListUpdate::mutable_roomname() {
  
  // @@protoc_insertion_point(field_mutable:RoomsListUpdate.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomsListUpdate::release_roomname() {
  // @@protoc_insertion_point(field_release:RoomsListUpdate.roomName)
  
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomsListUpdate::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    
  } else {
    
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:RoomsListUpdate.roomName)
}

// optional string roomOwner = 4;
inline void RoomsListUpdate::clear_roomowner() {
  roomowner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoomsListUpdate::roomowner() const {
  // @@protoc_insertion_point(field_get:RoomsListUpdate.roomOwner)
  return roomowner_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomsListUpdate::set_roomowner(const ::std::string& value) {
  
  roomowner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomsListUpdate.roomOwner)
}
inline void RoomsListUpdate::set_roomowner(const char* value) {
  
  roomowner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomsListUpdate.roomOwner)
}
inline void RoomsListUpdate::set_roomowner(const char* value, size_t size) {
  
  roomowner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomsListUpdate.roomOwner)
}
inline ::std::string* RoomsListUpdate::mutable_roomowner() {
  
  // @@protoc_insertion_point(field_mutable:RoomsListUpdate.roomOwner)
  return roomowner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomsListUpdate::release_roomowner() {
  // @@protoc_insertion_point(field_release:RoomsListUpdate.roomOwner)
  
  return roomowner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomsListUpdate::set_allocated_roomowner(::std::string* roomowner) {
  if (roomowner != NULL) {
    
  } else {
    
  }
  roomowner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomowner);
  // @@protoc_insertion_point(field_set_allocated:RoomsListUpdate.roomOwner)
}

// -------------------------------------------------------------------

// SubscribeRoom

// optional bool subscribe = 1;
inline bool SubscribeRoom::has_subscribe() const {
  return v1_case() == kSubscribe;
}
inline void SubscribeRoom::set_has_subscribe() {
  _oneof_case_[0] = kSubscribe;
}
inline void SubscribeRoom::clear_subscribe() {
  if (has_subscribe()) {
    v1_.subscribe_ = false;
    clear_has_v1();
  }
}
inline bool SubscribeRoom::subscribe() const {
  // @@protoc_insertion_point(field_get:SubscribeRoom.subscribe)
  if (has_subscribe()) {
    return v1_.subscribe_;
  }
  return false;
}
inline void SubscribeRoom::set_subscribe(bool value) {
  if (!has_subscribe()) {
    clear_v1();
    set_has_subscribe();
  }
  v1_.subscribe_ = value;
  // @@protoc_insertion_point(field_set:SubscribeRoom.subscribe)
}

// optional string roomName = 2;
inline void SubscribeRoom::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubscribeRoom::roomname() const {
  // @@protoc_insertion_point(field_get:SubscribeRoom.roomName)
  return roomname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeRoom::set_roomname(const ::std::string& value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SubscribeRoom.roomName)
}
inline void SubscribeRoom::set_roomname(const char* value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SubscribeRoom.roomName)
}
inline void SubscribeRoom::set_roomname(const char* value, size_t size) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SubscribeRoom.roomName)
}
inline ::std::string* SubscribeRoom::mutable_roomname() {
  
  // @@protoc_insertion_point(field_mutable:SubscribeRoom.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeRoom::release_roomname() {
  // @@protoc_insertion_point(field_release:SubscribeRoom.roomName)
  
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeRoom::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    
  } else {
    
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:SubscribeRoom.roomName)
}

// optional int32 stateCode = 3;
inline void SubscribeRoom::clear_statecode() {
  statecode_ = 0;
}
inline ::google::protobuf::int32 SubscribeRoom::statecode() const {
  // @@protoc_insertion_point(field_get:SubscribeRoom.stateCode)
  return statecode_;
}
inline void SubscribeRoom::set_statecode(::google::protobuf::int32 value) {
  
  statecode_ = value;
  // @@protoc_insertion_point(field_set:SubscribeRoom.stateCode)
}

// optional .RoomDescribe roomDescribe = 4;
inline bool SubscribeRoom::has_roomdescribe() const {
  return !_is_default_instance_ && roomdescribe_ != NULL;
}
inline void SubscribeRoom::clear_roomdescribe() {
  if (GetArenaNoVirtual() == NULL && roomdescribe_ != NULL) delete roomdescribe_;
  roomdescribe_ = NULL;
}
inline const ::RoomDescribe& SubscribeRoom::roomdescribe() const {
  // @@protoc_insertion_point(field_get:SubscribeRoom.roomDescribe)
  return roomdescribe_ != NULL ? *roomdescribe_ : *default_instance_->roomdescribe_;
}
inline ::RoomDescribe* SubscribeRoom::mutable_roomdescribe() {
  
  if (roomdescribe_ == NULL) {
    roomdescribe_ = new ::RoomDescribe;
  }
  // @@protoc_insertion_point(field_mutable:SubscribeRoom.roomDescribe)
  return roomdescribe_;
}
inline ::RoomDescribe* SubscribeRoom::release_roomdescribe() {
  // @@protoc_insertion_point(field_release:SubscribeRoom.roomDescribe)
  
  ::RoomDescribe* temp = roomdescribe_;
  roomdescribe_ = NULL;
  return temp;
}
inline void SubscribeRoom::set_allocated_roomdescribe(::RoomDescribe* roomdescribe) {
  delete roomdescribe_;
  roomdescribe_ = roomdescribe;
  if (roomdescribe) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SubscribeRoom.roomDescribe)
}

// optional string player = 5;
inline void SubscribeRoom::clear_player() {
  player_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubscribeRoom::player() const {
  // @@protoc_insertion_point(field_get:SubscribeRoom.player)
  return player_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeRoom::set_player(const ::std::string& value) {
  
  player_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SubscribeRoom.player)
}
inline void SubscribeRoom::set_player(const char* value) {
  
  player_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SubscribeRoom.player)
}
inline void SubscribeRoom::set_player(const char* value, size_t size) {
  
  player_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SubscribeRoom.player)
}
inline ::std::string* SubscribeRoom::mutable_player() {
  
  // @@protoc_insertion_point(field_mutable:SubscribeRoom.player)
  return player_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeRoom::release_player() {
  // @@protoc_insertion_point(field_release:SubscribeRoom.player)
  
  return player_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeRoom::set_allocated_player(::std::string* player) {
  if (player != NULL) {
    
  } else {
    
  }
  player_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), player);
  // @@protoc_insertion_point(field_set_allocated:SubscribeRoom.player)
}

// optional string team = 6;
inline void SubscribeRoom::clear_team() {
  team_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubscribeRoom::team() const {
  // @@protoc_insertion_point(field_get:SubscribeRoom.team)
  return team_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeRoom::set_team(const ::std::string& value) {
  
  team_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SubscribeRoom.team)
}
inline void SubscribeRoom::set_team(const char* value) {
  
  team_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SubscribeRoom.team)
}
inline void SubscribeRoom::set_team(const char* value, size_t size) {
  
  team_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SubscribeRoom.team)
}
inline ::std::string* SubscribeRoom::mutable_team() {
  
  // @@protoc_insertion_point(field_mutable:SubscribeRoom.team)
  return team_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeRoom::release_team() {
  // @@protoc_insertion_point(field_release:SubscribeRoom.team)
  
  return team_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeRoom::set_allocated_team(::std::string* team) {
  if (team != NULL) {
    
  } else {
    
  }
  team_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team);
  // @@protoc_insertion_point(field_set_allocated:SubscribeRoom.team)
}

inline bool SubscribeRoom::has_v1() const {
  return v1_case() != V1_NOT_SET;
}
inline void SubscribeRoom::clear_has_v1() {
  _oneof_case_[0] = V1_NOT_SET;
}
inline SubscribeRoom::V1Case SubscribeRoom::v1_case() const {
  return SubscribeRoom::V1Case(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RoomDescribe

// repeated .TeamPlayer team1 = 1;
inline int RoomDescribe::team1_size() const {
  return team1_.size();
}
inline void RoomDescribe::clear_team1() {
  team1_.Clear();
}
inline const ::TeamPlayer& RoomDescribe::team1(int index) const {
  // @@protoc_insertion_point(field_get:RoomDescribe.team1)
  return team1_.Get(index);
}
inline ::TeamPlayer* RoomDescribe::mutable_team1(int index) {
  // @@protoc_insertion_point(field_mutable:RoomDescribe.team1)
  return team1_.Mutable(index);
}
inline ::TeamPlayer* RoomDescribe::add_team1() {
  // @@protoc_insertion_point(field_add:RoomDescribe.team1)
  return team1_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TeamPlayer >*
RoomDescribe::mutable_team1() {
  // @@protoc_insertion_point(field_mutable_list:RoomDescribe.team1)
  return &team1_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TeamPlayer >&
RoomDescribe::team1() const {
  // @@protoc_insertion_point(field_list:RoomDescribe.team1)
  return team1_;
}

// repeated .TeamPlayer team2 = 2;
inline int RoomDescribe::team2_size() const {
  return team2_.size();
}
inline void RoomDescribe::clear_team2() {
  team2_.Clear();
}
inline const ::TeamPlayer& RoomDescribe::team2(int index) const {
  // @@protoc_insertion_point(field_get:RoomDescribe.team2)
  return team2_.Get(index);
}
inline ::TeamPlayer* RoomDescribe::mutable_team2(int index) {
  // @@protoc_insertion_point(field_mutable:RoomDescribe.team2)
  return team2_.Mutable(index);
}
inline ::TeamPlayer* RoomDescribe::add_team2() {
  // @@protoc_insertion_point(field_add:RoomDescribe.team2)
  return team2_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TeamPlayer >*
RoomDescribe::mutable_team2() {
  // @@protoc_insertion_point(field_mutable_list:RoomDescribe.team2)
  return &team2_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TeamPlayer >&
RoomDescribe::team2() const {
  // @@protoc_insertion_point(field_list:RoomDescribe.team2)
  return team2_;
}

// repeated .TeamPlayer undistributed = 3;
inline int RoomDescribe::undistributed_size() const {
  return undistributed_.size();
}
inline void RoomDescribe::clear_undistributed() {
  undistributed_.Clear();
}
inline const ::TeamPlayer& RoomDescribe::undistributed(int index) const {
  // @@protoc_insertion_point(field_get:RoomDescribe.undistributed)
  return undistributed_.Get(index);
}
inline ::TeamPlayer* RoomDescribe::mutable_undistributed(int index) {
  // @@protoc_insertion_point(field_mutable:RoomDescribe.undistributed)
  return undistributed_.Mutable(index);
}
inline ::TeamPlayer* RoomDescribe::add_undistributed() {
  // @@protoc_insertion_point(field_add:RoomDescribe.undistributed)
  return undistributed_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TeamPlayer >*
RoomDescribe::mutable_undistributed() {
  // @@protoc_insertion_point(field_mutable_list:RoomDescribe.undistributed)
  return &undistributed_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TeamPlayer >&
RoomDescribe::undistributed() const {
  // @@protoc_insertion_point(field_list:RoomDescribe.undistributed)
  return undistributed_;
}

// optional string roomName = 4;
inline void RoomDescribe::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoomDescribe::roomname() const {
  // @@protoc_insertion_point(field_get:RoomDescribe.roomName)
  return roomname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomDescribe::set_roomname(const ::std::string& value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomDescribe.roomName)
}
inline void RoomDescribe::set_roomname(const char* value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomDescribe.roomName)
}
inline void RoomDescribe::set_roomname(const char* value, size_t size) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomDescribe.roomName)
}
inline ::std::string* RoomDescribe::mutable_roomname() {
  
  // @@protoc_insertion_point(field_mutable:RoomDescribe.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomDescribe::release_roomname() {
  // @@protoc_insertion_point(field_release:RoomDescribe.roomName)
  
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomDescribe::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    
  } else {
    
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:RoomDescribe.roomName)
}

// optional string mapName = 5;
inline void RoomDescribe::clear_mapname() {
  mapname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoomDescribe::mapname() const {
  // @@protoc_insertion_point(field_get:RoomDescribe.mapName)
  return mapname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomDescribe::set_mapname(const ::std::string& value) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomDescribe.mapName)
}
inline void RoomDescribe::set_mapname(const char* value) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomDescribe.mapName)
}
inline void RoomDescribe::set_mapname(const char* value, size_t size) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomDescribe.mapName)
}
inline ::std::string* RoomDescribe::mutable_mapname() {
  
  // @@protoc_insertion_point(field_mutable:RoomDescribe.mapName)
  return mapname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomDescribe::release_mapname() {
  // @@protoc_insertion_point(field_release:RoomDescribe.mapName)
  
  return mapname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomDescribe::set_allocated_mapname(::std::string* mapname) {
  if (mapname != NULL) {
    
  } else {
    
  }
  mapname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapname);
  // @@protoc_insertion_point(field_set_allocated:RoomDescribe.mapName)
}

// optional string gameTime = 6;
inline void RoomDescribe::clear_gametime() {
  gametime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoomDescribe::gametime() const {
  // @@protoc_insertion_point(field_get:RoomDescribe.gameTime)
  return gametime_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomDescribe::set_gametime(const ::std::string& value) {
  
  gametime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomDescribe.gameTime)
}
inline void RoomDescribe::set_gametime(const char* value) {
  
  gametime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomDescribe.gameTime)
}
inline void RoomDescribe::set_gametime(const char* value, size_t size) {
  
  gametime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomDescribe.gameTime)
}
inline ::std::string* RoomDescribe::mutable_gametime() {
  
  // @@protoc_insertion_point(field_mutable:RoomDescribe.gameTime)
  return gametime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomDescribe::release_gametime() {
  // @@protoc_insertion_point(field_release:RoomDescribe.gameTime)
  
  return gametime_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomDescribe::set_allocated_gametime(::std::string* gametime) {
  if (gametime != NULL) {
    
  } else {
    
  }
  gametime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gametime);
  // @@protoc_insertion_point(field_set_allocated:RoomDescribe.gameTime)
}

// optional string maxPlayers = 7;
inline void RoomDescribe::clear_maxplayers() {
  maxplayers_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoomDescribe::maxplayers() const {
  // @@protoc_insertion_point(field_get:RoomDescribe.maxPlayers)
  return maxplayers_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomDescribe::set_maxplayers(const ::std::string& value) {
  
  maxplayers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomDescribe.maxPlayers)
}
inline void RoomDescribe::set_maxplayers(const char* value) {
  
  maxplayers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomDescribe.maxPlayers)
}
inline void RoomDescribe::set_maxplayers(const char* value, size_t size) {
  
  maxplayers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomDescribe.maxPlayers)
}
inline ::std::string* RoomDescribe::mutable_maxplayers() {
  
  // @@protoc_insertion_point(field_mutable:RoomDescribe.maxPlayers)
  return maxplayers_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomDescribe::release_maxplayers() {
  // @@protoc_insertion_point(field_release:RoomDescribe.maxPlayers)
  
  return maxplayers_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomDescribe::set_allocated_maxplayers(::std::string* maxplayers) {
  if (maxplayers != NULL) {
    
  } else {
    
  }
  maxplayers_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), maxplayers);
  // @@protoc_insertion_point(field_set_allocated:RoomDescribe.maxPlayers)
}

// optional string creator = 8;
inline void RoomDescribe::clear_creator() {
  creator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoomDescribe::creator() const {
  // @@protoc_insertion_point(field_get:RoomDescribe.creator)
  return creator_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomDescribe::set_creator(const ::std::string& value) {
  
  creator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomDescribe.creator)
}
inline void RoomDescribe::set_creator(const char* value) {
  
  creator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomDescribe.creator)
}
inline void RoomDescribe::set_creator(const char* value, size_t size) {
  
  creator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomDescribe.creator)
}
inline ::std::string* RoomDescribe::mutable_creator() {
  
  // @@protoc_insertion_point(field_mutable:RoomDescribe.creator)
  return creator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomDescribe::release_creator() {
  // @@protoc_insertion_point(field_release:RoomDescribe.creator)
  
  return creator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomDescribe::set_allocated_creator(::std::string* creator) {
  if (creator != NULL) {
    
  } else {
    
  }
  creator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), creator);
  // @@protoc_insertion_point(field_set_allocated:RoomDescribe.creator)
}

// optional .Chat chat = 9;
inline bool RoomDescribe::has_chat() const {
  return !_is_default_instance_ && chat_ != NULL;
}
inline void RoomDescribe::clear_chat() {
  if (GetArenaNoVirtual() == NULL && chat_ != NULL) delete chat_;
  chat_ = NULL;
}
inline const ::Chat& RoomDescribe::chat() const {
  // @@protoc_insertion_point(field_get:RoomDescribe.chat)
  return chat_ != NULL ? *chat_ : *default_instance_->chat_;
}
inline ::Chat* RoomDescribe::mutable_chat() {
  
  if (chat_ == NULL) {
    chat_ = new ::Chat;
  }
  // @@protoc_insertion_point(field_mutable:RoomDescribe.chat)
  return chat_;
}
inline ::Chat* RoomDescribe::release_chat() {
  // @@protoc_insertion_point(field_release:RoomDescribe.chat)
  
  ::Chat* temp = chat_;
  chat_ = NULL;
  return temp;
}
inline void RoomDescribe::set_allocated_chat(::Chat* chat) {
  delete chat_;
  chat_ = chat;
  if (chat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:RoomDescribe.chat)
}

// -------------------------------------------------------------------

// TeamPlayer

// optional string player_name = 1;
inline void TeamPlayer::clear_player_name() {
  player_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TeamPlayer::player_name() const {
  // @@protoc_insertion_point(field_get:TeamPlayer.player_name)
  return player_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TeamPlayer::set_player_name(const ::std::string& value) {
  
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TeamPlayer.player_name)
}
inline void TeamPlayer::set_player_name(const char* value) {
  
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TeamPlayer.player_name)
}
inline void TeamPlayer::set_player_name(const char* value, size_t size) {
  
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TeamPlayer.player_name)
}
inline ::std::string* TeamPlayer::mutable_player_name() {
  
  // @@protoc_insertion_point(field_mutable:TeamPlayer.player_name)
  return player_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TeamPlayer::release_player_name() {
  // @@protoc_insertion_point(field_release:TeamPlayer.player_name)
  
  return player_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TeamPlayer::set_allocated_player_name(::std::string* player_name) {
  if (player_name != NULL) {
    
  } else {
    
  }
  player_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), player_name);
  // @@protoc_insertion_point(field_set_allocated:TeamPlayer.player_name)
}

// -------------------------------------------------------------------

// RoomUpdate

// optional .RoomDescribe roomDescribe = 1;
inline bool RoomUpdate::has_roomdescribe() const {
  return !_is_default_instance_ && roomdescribe_ != NULL;
}
inline void RoomUpdate::clear_roomdescribe() {
  if (GetArenaNoVirtual() == NULL && roomdescribe_ != NULL) delete roomdescribe_;
  roomdescribe_ = NULL;
}
inline const ::RoomDescribe& RoomUpdate::roomdescribe() const {
  // @@protoc_insertion_point(field_get:RoomUpdate.roomDescribe)
  return roomdescribe_ != NULL ? *roomdescribe_ : *default_instance_->roomdescribe_;
}
inline ::RoomDescribe* RoomUpdate::mutable_roomdescribe() {
  
  if (roomdescribe_ == NULL) {
    roomdescribe_ = new ::RoomDescribe;
  }
  // @@protoc_insertion_point(field_mutable:RoomUpdate.roomDescribe)
  return roomdescribe_;
}
inline ::RoomDescribe* RoomUpdate::release_roomdescribe() {
  // @@protoc_insertion_point(field_release:RoomUpdate.roomDescribe)
  
  ::RoomDescribe* temp = roomdescribe_;
  roomdescribe_ = NULL;
  return temp;
}
inline void RoomUpdate::set_allocated_roomdescribe(::RoomDescribe* roomdescribe) {
  delete roomdescribe_;
  roomdescribe_ = roomdescribe;
  if (roomdescribe) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:RoomUpdate.roomDescribe)
}

// optional string targetTeam = 2;
inline void RoomUpdate::clear_targetteam() {
  targetteam_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoomUpdate::targetteam() const {
  // @@protoc_insertion_point(field_get:RoomUpdate.targetTeam)
  return targetteam_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomUpdate::set_targetteam(const ::std::string& value) {
  
  targetteam_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomUpdate.targetTeam)
}
inline void RoomUpdate::set_targetteam(const char* value) {
  
  targetteam_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomUpdate.targetTeam)
}
inline void RoomUpdate::set_targetteam(const char* value, size_t size) {
  
  targetteam_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomUpdate.targetTeam)
}
inline ::std::string* RoomUpdate::mutable_targetteam() {
  
  // @@protoc_insertion_point(field_mutable:RoomUpdate.targetTeam)
  return targetteam_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomUpdate::release_targetteam() {
  // @@protoc_insertion_point(field_release:RoomUpdate.targetTeam)
  
  return targetteam_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomUpdate::set_allocated_targetteam(::std::string* targetteam) {
  if (targetteam != NULL) {
    
  } else {
    
  }
  targetteam_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), targetteam);
  // @@protoc_insertion_point(field_set_allocated:RoomUpdate.targetTeam)
}

// optional string roomName = 3;
inline void RoomUpdate::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoomUpdate::roomname() const {
  // @@protoc_insertion_point(field_get:RoomUpdate.roomName)
  return roomname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomUpdate::set_roomname(const ::std::string& value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomUpdate.roomName)
}
inline void RoomUpdate::set_roomname(const char* value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomUpdate.roomName)
}
inline void RoomUpdate::set_roomname(const char* value, size_t size) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomUpdate.roomName)
}
inline ::std::string* RoomUpdate::mutable_roomname() {
  
  // @@protoc_insertion_point(field_mutable:RoomUpdate.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomUpdate::release_roomname() {
  // @@protoc_insertion_point(field_release:RoomUpdate.roomName)
  
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomUpdate::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    
  } else {
    
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:RoomUpdate.roomName)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GameRoomModels_2eproto__INCLUDED
