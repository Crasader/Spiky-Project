// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RegLogModels.proto

#ifndef PROTOBUF_RegLogModels_2eproto__INCLUDED
#define PROTOBUF_RegLogModels_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "DisableWarnings.pb.h"
#include "GameRoomModels.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_RegLogModels_2eproto();
void protobuf_AssignDesc_RegLogModels_2eproto();
void protobuf_ShutdownFile_RegLogModels_2eproto();

class InitialState;
class InputChecking;
class Login;
class Registration;

// ===================================================================

class InputChecking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InputChecking) */ {
 public:
  InputChecking();
  virtual ~InputChecking();

  InputChecking(const InputChecking& from);

  inline InputChecking& operator=(const InputChecking& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputChecking& default_instance();

  enum V1Case {
    kLoginCheckStatus = 6,
    kMailCheckStatus = 7,
    kCaptchaCheckStatus = 8,
    V1_NOT_SET = 0,
  };

  void Swap(InputChecking* other);

  // implements Message ----------------------------------------------

  inline InputChecking* New() const { return New(NULL); }

  InputChecking* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputChecking& from);
  void MergeFrom(const InputChecking& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InputChecking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string login = 1;
  void clear_login();
  static const int kLoginFieldNumber = 1;
  const ::std::string& login() const;
  void set_login(const ::std::string& value);
  void set_login(const char* value);
  void set_login(const char* value, size_t size);
  ::std::string* mutable_login();
  ::std::string* release_login();
  void set_allocated_login(::std::string* login);

  // optional string mail = 2;
  void clear_mail();
  static const int kMailFieldNumber = 2;
  const ::std::string& mail() const;
  void set_mail(const ::std::string& value);
  void set_mail(const char* value);
  void set_mail(const char* value, size_t size);
  ::std::string* mutable_mail();
  ::std::string* release_mail();
  void set_allocated_mail(::std::string* mail);

  // optional string captcha = 3;
  void clear_captcha();
  static const int kCaptchaFieldNumber = 3;
  const ::std::string& captcha() const;
  void set_captcha(const ::std::string& value);
  void set_captcha(const char* value);
  void set_captcha(const char* value, size_t size);
  ::std::string* mutable_captcha();
  ::std::string* release_captcha();
  void set_allocated_captcha(::std::string* captcha);

  // optional bool getCaptcha = 4;
  void clear_getcaptcha();
  static const int kGetCaptchaFieldNumber = 4;
  bool getcaptcha() const;
  void set_getcaptcha(bool value);

  // optional bytes captchaData = 5;
  void clear_captchadata();
  static const int kCaptchaDataFieldNumber = 5;
  const ::std::string& captchadata() const;
  void set_captchadata(const ::std::string& value);
  void set_captchadata(const char* value);
  void set_captchadata(const void* value, size_t size);
  ::std::string* mutable_captchadata();
  ::std::string* release_captchadata();
  void set_allocated_captchadata(::std::string* captchadata);

  // optional bool loginCheckStatus = 6;
  private:
  bool has_logincheckstatus() const;
  public:
  void clear_logincheckstatus();
  static const int kLoginCheckStatusFieldNumber = 6;
  bool logincheckstatus() const;
  void set_logincheckstatus(bool value);

  // optional bool mailCheckStatus = 7;
  private:
  bool has_mailcheckstatus() const;
  public:
  void clear_mailcheckstatus();
  static const int kMailCheckStatusFieldNumber = 7;
  bool mailcheckstatus() const;
  void set_mailcheckstatus(bool value);

  // optional bool captchaCheckStatus = 8;
  private:
  bool has_captchacheckstatus() const;
  public:
  void clear_captchacheckstatus();
  static const int kCaptchaCheckStatusFieldNumber = 8;
  bool captchacheckstatus() const;
  void set_captchacheckstatus(bool value);

  V1Case v1_case() const;
  // @@protoc_insertion_point(class_scope:InputChecking)
 private:
  inline void set_has_logincheckstatus();
  inline void set_has_mailcheckstatus();
  inline void set_has_captchacheckstatus();

  inline bool has_v1() const;
  void clear_v1();
  inline void clear_has_v1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr login_;
  ::google::protobuf::internal::ArenaStringPtr mail_;
  ::google::protobuf::internal::ArenaStringPtr captcha_;
  ::google::protobuf::internal::ArenaStringPtr captchadata_;
  bool getcaptcha_;
  union V1Union {
    V1Union() {}
    bool logincheckstatus_;
    bool mailcheckstatus_;
    bool captchacheckstatus_;
  } v1_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_RegLogModels_2eproto();
  friend void protobuf_AssignDesc_RegLogModels_2eproto();
  friend void protobuf_ShutdownFile_RegLogModels_2eproto();

  void InitAsDefaultInstance();
  static InputChecking* default_instance_;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  enum V1Case {
    kStateCode = 4,
    V1_NOT_SET = 0,
  };

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  inline Login* New() const { return New(NULL); }

  Login* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mail = 1;
  void clear_mail();
  static const int kMailFieldNumber = 1;
  const ::std::string& mail() const;
  void set_mail(const ::std::string& value);
  void set_mail(const char* value);
  void set_mail(const char* value, size_t size);
  ::std::string* mutable_mail();
  ::std::string* release_mail();
  void set_allocated_mail(::std::string* mail);

  // optional string hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional string publicKey = 3;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 3;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional int32 stateCode = 4;
  private:
  bool has_statecode() const;
  public:
  void clear_statecode();
  static const int kStateCodeFieldNumber = 4;
  ::google::protobuf::int32 statecode() const;
  void set_statecode(::google::protobuf::int32 value);

  V1Case v1_case() const;
  // @@protoc_insertion_point(class_scope:Login)
 private:
  inline void set_has_statecode();

  inline bool has_v1() const;
  void clear_v1();
  inline void clear_has_v1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr mail_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  union V1Union {
    V1Union() {}
    ::google::protobuf::int32 statecode_;
  } v1_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_RegLogModels_2eproto();
  friend void protobuf_AssignDesc_RegLogModels_2eproto();
  friend void protobuf_ShutdownFile_RegLogModels_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class Registration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Registration) */ {
 public:
  Registration();
  virtual ~Registration();

  Registration(const Registration& from);

  inline Registration& operator=(const Registration& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Registration& default_instance();

  enum V1Case {
    kStateCode = 6,
    V1_NOT_SET = 0,
  };

  void Swap(Registration* other);

  // implements Message ----------------------------------------------

  inline Registration* New() const { return New(NULL); }

  Registration* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Registration& from);
  void MergeFrom(const Registration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Registration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string login = 1;
  void clear_login();
  static const int kLoginFieldNumber = 1;
  const ::std::string& login() const;
  void set_login(const ::std::string& value);
  void set_login(const char* value);
  void set_login(const char* value, size_t size);
  ::std::string* mutable_login();
  ::std::string* release_login();
  void set_allocated_login(::std::string* login);

  // optional string hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional string mail = 3;
  void clear_mail();
  static const int kMailFieldNumber = 3;
  const ::std::string& mail() const;
  void set_mail(const ::std::string& value);
  void set_mail(const char* value);
  void set_mail(const char* value, size_t size);
  ::std::string* mutable_mail();
  ::std::string* release_mail();
  void set_allocated_mail(::std::string* mail);

  // optional string captcha = 4;
  void clear_captcha();
  static const int kCaptchaFieldNumber = 4;
  const ::std::string& captcha() const;
  void set_captcha(const ::std::string& value);
  void set_captcha(const char* value);
  void set_captcha(const char* value, size_t size);
  ::std::string* mutable_captcha();
  ::std::string* release_captcha();
  void set_allocated_captcha(::std::string* captcha);

  // optional string publicKey = 5;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 5;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional int32 stateCode = 6;
  private:
  bool has_statecode() const;
  public:
  void clear_statecode();
  static const int kStateCodeFieldNumber = 6;
  ::google::protobuf::int32 statecode() const;
  void set_statecode(::google::protobuf::int32 value);

  V1Case v1_case() const;
  // @@protoc_insertion_point(class_scope:Registration)
 private:
  inline void set_has_statecode();

  inline bool has_v1() const;
  void clear_v1();
  inline void clear_has_v1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr login_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr mail_;
  ::google::protobuf::internal::ArenaStringPtr captcha_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  union V1Union {
    V1Union() {}
    ::google::protobuf::int32 statecode_;
  } v1_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_RegLogModels_2eproto();
  friend void protobuf_AssignDesc_RegLogModels_2eproto();
  friend void protobuf_ShutdownFile_RegLogModels_2eproto();

  void InitAsDefaultInstance();
  static Registration* default_instance_;
};
// -------------------------------------------------------------------

class InitialState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InitialState) */ {
 public:
  InitialState();
  virtual ~InitialState();

  InitialState(const InitialState& from);

  inline InitialState& operator=(const InitialState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitialState& default_instance();

  void Swap(InitialState* other);

  // implements Message ----------------------------------------------

  inline InitialState* New() const { return New(NULL); }

  InitialState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitialState& from);
  void MergeFrom(const InitialState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitialState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sessionId = 1;
  void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  const ::std::string& sessionid() const;
  void set_sessionid(const ::std::string& value);
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  ::std::string* mutable_sessionid();
  ::std::string* release_sessionid();
  void set_allocated_sessionid(::std::string* sessionid);

  // optional string login = 2;
  void clear_login();
  static const int kLoginFieldNumber = 2;
  const ::std::string& login() const;
  void set_login(const ::std::string& value);
  void set_login(const char* value);
  void set_login(const char* value, size_t size);
  ::std::string* mutable_login();
  ::std::string* release_login();
  void set_allocated_login(::std::string* login);

  // repeated .CreateRoom createRoom = 3;
  int createroom_size() const;
  void clear_createroom();
  static const int kCreateRoomFieldNumber = 3;
  const ::CreateRoom& createroom(int index) const;
  ::CreateRoom* mutable_createroom(int index);
  ::CreateRoom* add_createroom();
  ::google::protobuf::RepeatedPtrField< ::CreateRoom >*
      mutable_createroom();
  const ::google::protobuf::RepeatedPtrField< ::CreateRoom >&
      createroom() const;

  // @@protoc_insertion_point(class_scope:InitialState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sessionid_;
  ::google::protobuf::internal::ArenaStringPtr login_;
  ::google::protobuf::RepeatedPtrField< ::CreateRoom > createroom_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RegLogModels_2eproto();
  friend void protobuf_AssignDesc_RegLogModels_2eproto();
  friend void protobuf_ShutdownFile_RegLogModels_2eproto();

  void InitAsDefaultInstance();
  static InitialState* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// InputChecking

// optional string login = 1;
inline void InputChecking::clear_login() {
  login_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InputChecking::login() const {
  // @@protoc_insertion_point(field_get:InputChecking.login)
  return login_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputChecking::set_login(const ::std::string& value) {
  
  login_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputChecking.login)
}
inline void InputChecking::set_login(const char* value) {
  
  login_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputChecking.login)
}
inline void InputChecking::set_login(const char* value, size_t size) {
  
  login_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputChecking.login)
}
inline ::std::string* InputChecking::mutable_login() {
  
  // @@protoc_insertion_point(field_mutable:InputChecking.login)
  return login_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputChecking::release_login() {
  // @@protoc_insertion_point(field_release:InputChecking.login)
  
  return login_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputChecking::set_allocated_login(::std::string* login) {
  if (login != NULL) {
    
  } else {
    
  }
  login_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), login);
  // @@protoc_insertion_point(field_set_allocated:InputChecking.login)
}

// optional string mail = 2;
inline void InputChecking::clear_mail() {
  mail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InputChecking::mail() const {
  // @@protoc_insertion_point(field_get:InputChecking.mail)
  return mail_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputChecking::set_mail(const ::std::string& value) {
  
  mail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputChecking.mail)
}
inline void InputChecking::set_mail(const char* value) {
  
  mail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputChecking.mail)
}
inline void InputChecking::set_mail(const char* value, size_t size) {
  
  mail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputChecking.mail)
}
inline ::std::string* InputChecking::mutable_mail() {
  
  // @@protoc_insertion_point(field_mutable:InputChecking.mail)
  return mail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputChecking::release_mail() {
  // @@protoc_insertion_point(field_release:InputChecking.mail)
  
  return mail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputChecking::set_allocated_mail(::std::string* mail) {
  if (mail != NULL) {
    
  } else {
    
  }
  mail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mail);
  // @@protoc_insertion_point(field_set_allocated:InputChecking.mail)
}

// optional string captcha = 3;
inline void InputChecking::clear_captcha() {
  captcha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InputChecking::captcha() const {
  // @@protoc_insertion_point(field_get:InputChecking.captcha)
  return captcha_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputChecking::set_captcha(const ::std::string& value) {
  
  captcha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputChecking.captcha)
}
inline void InputChecking::set_captcha(const char* value) {
  
  captcha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputChecking.captcha)
}
inline void InputChecking::set_captcha(const char* value, size_t size) {
  
  captcha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputChecking.captcha)
}
inline ::std::string* InputChecking::mutable_captcha() {
  
  // @@protoc_insertion_point(field_mutable:InputChecking.captcha)
  return captcha_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputChecking::release_captcha() {
  // @@protoc_insertion_point(field_release:InputChecking.captcha)
  
  return captcha_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputChecking::set_allocated_captcha(::std::string* captcha) {
  if (captcha != NULL) {
    
  } else {
    
  }
  captcha_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), captcha);
  // @@protoc_insertion_point(field_set_allocated:InputChecking.captcha)
}

// optional bool getCaptcha = 4;
inline void InputChecking::clear_getcaptcha() {
  getcaptcha_ = false;
}
inline bool InputChecking::getcaptcha() const {
  // @@protoc_insertion_point(field_get:InputChecking.getCaptcha)
  return getcaptcha_;
}
inline void InputChecking::set_getcaptcha(bool value) {
  
  getcaptcha_ = value;
  // @@protoc_insertion_point(field_set:InputChecking.getCaptcha)
}

// optional bytes captchaData = 5;
inline void InputChecking::clear_captchadata() {
  captchadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InputChecking::captchadata() const {
  // @@protoc_insertion_point(field_get:InputChecking.captchaData)
  return captchadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputChecking::set_captchadata(const ::std::string& value) {
  
  captchadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputChecking.captchaData)
}
inline void InputChecking::set_captchadata(const char* value) {
  
  captchadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputChecking.captchaData)
}
inline void InputChecking::set_captchadata(const void* value, size_t size) {
  
  captchadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputChecking.captchaData)
}
inline ::std::string* InputChecking::mutable_captchadata() {
  
  // @@protoc_insertion_point(field_mutable:InputChecking.captchaData)
  return captchadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputChecking::release_captchadata() {
  // @@protoc_insertion_point(field_release:InputChecking.captchaData)
  
  return captchadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputChecking::set_allocated_captchadata(::std::string* captchadata) {
  if (captchadata != NULL) {
    
  } else {
    
  }
  captchadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), captchadata);
  // @@protoc_insertion_point(field_set_allocated:InputChecking.captchaData)
}

// optional bool loginCheckStatus = 6;
inline bool InputChecking::has_logincheckstatus() const {
  return v1_case() == kLoginCheckStatus;
}
inline void InputChecking::set_has_logincheckstatus() {
  _oneof_case_[0] = kLoginCheckStatus;
}
inline void InputChecking::clear_logincheckstatus() {
  if (has_logincheckstatus()) {
    v1_.logincheckstatus_ = false;
    clear_has_v1();
  }
}
inline bool InputChecking::logincheckstatus() const {
  // @@protoc_insertion_point(field_get:InputChecking.loginCheckStatus)
  if (has_logincheckstatus()) {
    return v1_.logincheckstatus_;
  }
  return false;
}
inline void InputChecking::set_logincheckstatus(bool value) {
  if (!has_logincheckstatus()) {
    clear_v1();
    set_has_logincheckstatus();
  }
  v1_.logincheckstatus_ = value;
  // @@protoc_insertion_point(field_set:InputChecking.loginCheckStatus)
}

// optional bool mailCheckStatus = 7;
inline bool InputChecking::has_mailcheckstatus() const {
  return v1_case() == kMailCheckStatus;
}
inline void InputChecking::set_has_mailcheckstatus() {
  _oneof_case_[0] = kMailCheckStatus;
}
inline void InputChecking::clear_mailcheckstatus() {
  if (has_mailcheckstatus()) {
    v1_.mailcheckstatus_ = false;
    clear_has_v1();
  }
}
inline bool InputChecking::mailcheckstatus() const {
  // @@protoc_insertion_point(field_get:InputChecking.mailCheckStatus)
  if (has_mailcheckstatus()) {
    return v1_.mailcheckstatus_;
  }
  return false;
}
inline void InputChecking::set_mailcheckstatus(bool value) {
  if (!has_mailcheckstatus()) {
    clear_v1();
    set_has_mailcheckstatus();
  }
  v1_.mailcheckstatus_ = value;
  // @@protoc_insertion_point(field_set:InputChecking.mailCheckStatus)
}

// optional bool captchaCheckStatus = 8;
inline bool InputChecking::has_captchacheckstatus() const {
  return v1_case() == kCaptchaCheckStatus;
}
inline void InputChecking::set_has_captchacheckstatus() {
  _oneof_case_[0] = kCaptchaCheckStatus;
}
inline void InputChecking::clear_captchacheckstatus() {
  if (has_captchacheckstatus()) {
    v1_.captchacheckstatus_ = false;
    clear_has_v1();
  }
}
inline bool InputChecking::captchacheckstatus() const {
  // @@protoc_insertion_point(field_get:InputChecking.captchaCheckStatus)
  if (has_captchacheckstatus()) {
    return v1_.captchacheckstatus_;
  }
  return false;
}
inline void InputChecking::set_captchacheckstatus(bool value) {
  if (!has_captchacheckstatus()) {
    clear_v1();
    set_has_captchacheckstatus();
  }
  v1_.captchacheckstatus_ = value;
  // @@protoc_insertion_point(field_set:InputChecking.captchaCheckStatus)
}

inline bool InputChecking::has_v1() const {
  return v1_case() != V1_NOT_SET;
}
inline void InputChecking::clear_has_v1() {
  _oneof_case_[0] = V1_NOT_SET;
}
inline InputChecking::V1Case InputChecking::v1_case() const {
  return InputChecking::V1Case(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Login

// optional string mail = 1;
inline void Login::clear_mail() {
  mail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::mail() const {
  // @@protoc_insertion_point(field_get:Login.mail)
  return mail_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_mail(const ::std::string& value) {
  
  mail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Login.mail)
}
inline void Login::set_mail(const char* value) {
  
  mail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Login.mail)
}
inline void Login::set_mail(const char* value, size_t size) {
  
  mail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Login.mail)
}
inline ::std::string* Login::mutable_mail() {
  
  // @@protoc_insertion_point(field_mutable:Login.mail)
  return mail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_mail() {
  // @@protoc_insertion_point(field_release:Login.mail)
  
  return mail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_mail(::std::string* mail) {
  if (mail != NULL) {
    
  } else {
    
  }
  mail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mail);
  // @@protoc_insertion_point(field_set_allocated:Login.mail)
}

// optional string hash = 2;
inline void Login::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::hash() const {
  // @@protoc_insertion_point(field_get:Login.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Login.hash)
}
inline void Login::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Login.hash)
}
inline void Login::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Login.hash)
}
inline ::std::string* Login::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:Login.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_hash() {
  // @@protoc_insertion_point(field_release:Login.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:Login.hash)
}

// optional string publicKey = 3;
inline void Login::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::publickey() const {
  // @@protoc_insertion_point(field_get:Login.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Login.publicKey)
}
inline void Login::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Login.publicKey)
}
inline void Login::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Login.publicKey)
}
inline ::std::string* Login::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:Login.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_publickey() {
  // @@protoc_insertion_point(field_release:Login.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:Login.publicKey)
}

// optional int32 stateCode = 4;
inline bool Login::has_statecode() const {
  return v1_case() == kStateCode;
}
inline void Login::set_has_statecode() {
  _oneof_case_[0] = kStateCode;
}
inline void Login::clear_statecode() {
  if (has_statecode()) {
    v1_.statecode_ = 0;
    clear_has_v1();
  }
}
inline ::google::protobuf::int32 Login::statecode() const {
  // @@protoc_insertion_point(field_get:Login.stateCode)
  if (has_statecode()) {
    return v1_.statecode_;
  }
  return 0;
}
inline void Login::set_statecode(::google::protobuf::int32 value) {
  if (!has_statecode()) {
    clear_v1();
    set_has_statecode();
  }
  v1_.statecode_ = value;
  // @@protoc_insertion_point(field_set:Login.stateCode)
}

inline bool Login::has_v1() const {
  return v1_case() != V1_NOT_SET;
}
inline void Login::clear_has_v1() {
  _oneof_case_[0] = V1_NOT_SET;
}
inline Login::V1Case Login::v1_case() const {
  return Login::V1Case(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Registration

// optional string login = 1;
inline void Registration::clear_login() {
  login_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Registration::login() const {
  // @@protoc_insertion_point(field_get:Registration.login)
  return login_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Registration::set_login(const ::std::string& value) {
  
  login_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Registration.login)
}
inline void Registration::set_login(const char* value) {
  
  login_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Registration.login)
}
inline void Registration::set_login(const char* value, size_t size) {
  
  login_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Registration.login)
}
inline ::std::string* Registration::mutable_login() {
  
  // @@protoc_insertion_point(field_mutable:Registration.login)
  return login_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Registration::release_login() {
  // @@protoc_insertion_point(field_release:Registration.login)
  
  return login_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Registration::set_allocated_login(::std::string* login) {
  if (login != NULL) {
    
  } else {
    
  }
  login_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), login);
  // @@protoc_insertion_point(field_set_allocated:Registration.login)
}

// optional string hash = 2;
inline void Registration::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Registration::hash() const {
  // @@protoc_insertion_point(field_get:Registration.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Registration::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Registration.hash)
}
inline void Registration::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Registration.hash)
}
inline void Registration::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Registration.hash)
}
inline ::std::string* Registration::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:Registration.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Registration::release_hash() {
  // @@protoc_insertion_point(field_release:Registration.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Registration::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:Registration.hash)
}

// optional string mail = 3;
inline void Registration::clear_mail() {
  mail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Registration::mail() const {
  // @@protoc_insertion_point(field_get:Registration.mail)
  return mail_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Registration::set_mail(const ::std::string& value) {
  
  mail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Registration.mail)
}
inline void Registration::set_mail(const char* value) {
  
  mail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Registration.mail)
}
inline void Registration::set_mail(const char* value, size_t size) {
  
  mail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Registration.mail)
}
inline ::std::string* Registration::mutable_mail() {
  
  // @@protoc_insertion_point(field_mutable:Registration.mail)
  return mail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Registration::release_mail() {
  // @@protoc_insertion_point(field_release:Registration.mail)
  
  return mail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Registration::set_allocated_mail(::std::string* mail) {
  if (mail != NULL) {
    
  } else {
    
  }
  mail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mail);
  // @@protoc_insertion_point(field_set_allocated:Registration.mail)
}

// optional string captcha = 4;
inline void Registration::clear_captcha() {
  captcha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Registration::captcha() const {
  // @@protoc_insertion_point(field_get:Registration.captcha)
  return captcha_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Registration::set_captcha(const ::std::string& value) {
  
  captcha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Registration.captcha)
}
inline void Registration::set_captcha(const char* value) {
  
  captcha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Registration.captcha)
}
inline void Registration::set_captcha(const char* value, size_t size) {
  
  captcha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Registration.captcha)
}
inline ::std::string* Registration::mutable_captcha() {
  
  // @@protoc_insertion_point(field_mutable:Registration.captcha)
  return captcha_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Registration::release_captcha() {
  // @@protoc_insertion_point(field_release:Registration.captcha)
  
  return captcha_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Registration::set_allocated_captcha(::std::string* captcha) {
  if (captcha != NULL) {
    
  } else {
    
  }
  captcha_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), captcha);
  // @@protoc_insertion_point(field_set_allocated:Registration.captcha)
}

// optional string publicKey = 5;
inline void Registration::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Registration::publickey() const {
  // @@protoc_insertion_point(field_get:Registration.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Registration::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Registration.publicKey)
}
inline void Registration::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Registration.publicKey)
}
inline void Registration::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Registration.publicKey)
}
inline ::std::string* Registration::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:Registration.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Registration::release_publickey() {
  // @@protoc_insertion_point(field_release:Registration.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Registration::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:Registration.publicKey)
}

// optional int32 stateCode = 6;
inline bool Registration::has_statecode() const {
  return v1_case() == kStateCode;
}
inline void Registration::set_has_statecode() {
  _oneof_case_[0] = kStateCode;
}
inline void Registration::clear_statecode() {
  if (has_statecode()) {
    v1_.statecode_ = 0;
    clear_has_v1();
  }
}
inline ::google::protobuf::int32 Registration::statecode() const {
  // @@protoc_insertion_point(field_get:Registration.stateCode)
  if (has_statecode()) {
    return v1_.statecode_;
  }
  return 0;
}
inline void Registration::set_statecode(::google::protobuf::int32 value) {
  if (!has_statecode()) {
    clear_v1();
    set_has_statecode();
  }
  v1_.statecode_ = value;
  // @@protoc_insertion_point(field_set:Registration.stateCode)
}

inline bool Registration::has_v1() const {
  return v1_case() != V1_NOT_SET;
}
inline void Registration::clear_has_v1() {
  _oneof_case_[0] = V1_NOT_SET;
}
inline Registration::V1Case Registration::v1_case() const {
  return Registration::V1Case(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InitialState

// optional string sessionId = 1;
inline void InitialState::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InitialState::sessionid() const {
  // @@protoc_insertion_point(field_get:InitialState.sessionId)
  return sessionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitialState::set_sessionid(const ::std::string& value) {
  
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InitialState.sessionId)
}
inline void InitialState::set_sessionid(const char* value) {
  
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InitialState.sessionId)
}
inline void InitialState::set_sessionid(const char* value, size_t size) {
  
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InitialState.sessionId)
}
inline ::std::string* InitialState::mutable_sessionid() {
  
  // @@protoc_insertion_point(field_mutable:InitialState.sessionId)
  return sessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitialState::release_sessionid() {
  // @@protoc_insertion_point(field_release:InitialState.sessionId)
  
  return sessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitialState::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid != NULL) {
    
  } else {
    
  }
  sessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:InitialState.sessionId)
}

// optional string login = 2;
inline void InitialState::clear_login() {
  login_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InitialState::login() const {
  // @@protoc_insertion_point(field_get:InitialState.login)
  return login_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitialState::set_login(const ::std::string& value) {
  
  login_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InitialState.login)
}
inline void InitialState::set_login(const char* value) {
  
  login_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InitialState.login)
}
inline void InitialState::set_login(const char* value, size_t size) {
  
  login_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InitialState.login)
}
inline ::std::string* InitialState::mutable_login() {
  
  // @@protoc_insertion_point(field_mutable:InitialState.login)
  return login_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitialState::release_login() {
  // @@protoc_insertion_point(field_release:InitialState.login)
  
  return login_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitialState::set_allocated_login(::std::string* login) {
  if (login != NULL) {
    
  } else {
    
  }
  login_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), login);
  // @@protoc_insertion_point(field_set_allocated:InitialState.login)
}

// repeated .CreateRoom createRoom = 3;
inline int InitialState::createroom_size() const {
  return createroom_.size();
}
inline void InitialState::clear_createroom() {
  createroom_.Clear();
}
inline const ::CreateRoom& InitialState::createroom(int index) const {
  // @@protoc_insertion_point(field_get:InitialState.createRoom)
  return createroom_.Get(index);
}
inline ::CreateRoom* InitialState::mutable_createroom(int index) {
  // @@protoc_insertion_point(field_mutable:InitialState.createRoom)
  return createroom_.Mutable(index);
}
inline ::CreateRoom* InitialState::add_createroom() {
  // @@protoc_insertion_point(field_add:InitialState.createRoom)
  return createroom_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CreateRoom >*
InitialState::mutable_createroom() {
  // @@protoc_insertion_point(field_mutable_list:InitialState.createRoom)
  return &createroom_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CreateRoom >&
InitialState::createroom() const {
  // @@protoc_insertion_point(field_list:InitialState.createRoom)
  return createroom_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RegLogModels_2eproto__INCLUDED
