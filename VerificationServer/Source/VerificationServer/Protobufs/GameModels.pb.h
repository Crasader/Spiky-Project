// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameModels.proto

#ifndef PROTOBUF_GameModels_2eproto__INCLUDED
#define PROTOBUF_GameModels_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "DisableWarnings.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_GameModels_2eproto();
void protobuf_AssignDesc_GameModels_2eproto();
void protobuf_ShutdownFile_GameModels_2eproto();

class GameData;
class GameInitialState;
class Ping;
class Player;
class PlayerPosition;
class PlayerPosition_Location;
class PlayerPosition_Rotation;
class Shot;
class Shot_End;
class Shot_Start;

// ===================================================================

class GameInitialState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameInitialState) */ {
 public:
  GameInitialState();
  virtual ~GameInitialState();

  GameInitialState(const GameInitialState& from);

  inline GameInitialState& operator=(const GameInitialState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInitialState& default_instance();

  void Swap(GameInitialState* other);

  // implements Message ----------------------------------------------

  inline GameInitialState* New() const { return New(NULL); }

  GameInitialState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameInitialState& from);
  void MergeFrom(const GameInitialState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameInitialState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool startGame = 1;
  void clear_startgame();
  static const int kStartGameFieldNumber = 1;
  bool startgame() const;
  void set_startgame(bool value);

  // repeated .Player player = 2;
  int player_size() const;
  void clear_player();
  static const int kPlayerFieldNumber = 2;
  const ::Player& player(int index) const;
  ::Player* mutable_player(int index);
  ::Player* add_player();
  ::google::protobuf::RepeatedPtrField< ::Player >*
      mutable_player();
  const ::google::protobuf::RepeatedPtrField< ::Player >&
      player() const;

  // @@protoc_insertion_point(class_scope:GameInitialState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::Player > player_;
  bool startgame_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameModels_2eproto();
  friend void protobuf_AssignDesc_GameModels_2eproto();
  friend void protobuf_ShutdownFile_GameModels_2eproto();

  void InitAsDefaultInstance();
  static GameInitialState* default_instance_;
};
// -------------------------------------------------------------------

class Player : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Player) */ {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  void Swap(Player* other);

  // implements Message ----------------------------------------------

  inline Player* New() const { return New(NULL); }

  Player* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Player* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string player_name = 1;
  void clear_player_name();
  static const int kPlayerNameFieldNumber = 1;
  const ::std::string& player_name() const;
  void set_player_name(const ::std::string& value);
  void set_player_name(const char* value);
  void set_player_name(const char* value, size_t size);
  ::std::string* mutable_player_name();
  ::std::string* release_player_name();
  void set_allocated_player_name(::std::string* player_name);

  // optional string team = 2;
  void clear_team();
  static const int kTeamFieldNumber = 2;
  const ::std::string& team() const;
  void set_team(const ::std::string& value);
  void set_team(const char* value);
  void set_team(const char* value, size_t size);
  ::std::string* mutable_team();
  ::std::string* release_team();
  void set_allocated_team(::std::string* team);

  // optional int32 health = 3;
  void clear_health();
  static const int kHealthFieldNumber = 3;
  ::google::protobuf::int32 health() const;
  void set_health(::google::protobuf::int32 value);

  // optional .PlayerPosition playerPosition = 4;
  bool has_playerposition() const;
  void clear_playerposition();
  static const int kPlayerPositionFieldNumber = 4;
  const ::PlayerPosition& playerposition() const;
  ::PlayerPosition* mutable_playerposition();
  ::PlayerPosition* release_playerposition();
  void set_allocated_playerposition(::PlayerPosition* playerposition);

  // @@protoc_insertion_point(class_scope:Player)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr player_name_;
  ::google::protobuf::internal::ArenaStringPtr team_;
  ::PlayerPosition* playerposition_;
  ::google::protobuf::int32 health_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameModels_2eproto();
  friend void protobuf_AssignDesc_GameModels_2eproto();
  friend void protobuf_ShutdownFile_GameModels_2eproto();

  void InitAsDefaultInstance();
  static Player* default_instance_;
};
// -------------------------------------------------------------------

class PlayerPosition_Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PlayerPosition.Location) */ {
 public:
  PlayerPosition_Location();
  virtual ~PlayerPosition_Location();

  PlayerPosition_Location(const PlayerPosition_Location& from);

  inline PlayerPosition_Location& operator=(const PlayerPosition_Location& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerPosition_Location& default_instance();

  void Swap(PlayerPosition_Location* other);

  // implements Message ----------------------------------------------

  inline PlayerPosition_Location* New() const { return New(NULL); }

  PlayerPosition_Location* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerPosition_Location& from);
  void MergeFrom(const PlayerPosition_Location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerPosition_Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 X = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 Y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 Z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerPosition.Location)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameModels_2eproto();
  friend void protobuf_AssignDesc_GameModels_2eproto();
  friend void protobuf_ShutdownFile_GameModels_2eproto();

  void InitAsDefaultInstance();
  static PlayerPosition_Location* default_instance_;
};
// -------------------------------------------------------------------

class PlayerPosition_Rotation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PlayerPosition.Rotation) */ {
 public:
  PlayerPosition_Rotation();
  virtual ~PlayerPosition_Rotation();

  PlayerPosition_Rotation(const PlayerPosition_Rotation& from);

  inline PlayerPosition_Rotation& operator=(const PlayerPosition_Rotation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerPosition_Rotation& default_instance();

  void Swap(PlayerPosition_Rotation* other);

  // implements Message ----------------------------------------------

  inline PlayerPosition_Rotation* New() const { return New(NULL); }

  PlayerPosition_Rotation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerPosition_Rotation& from);
  void MergeFrom(const PlayerPosition_Rotation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerPosition_Rotation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 Pitch = 1;
  void clear_pitch();
  static const int kPitchFieldNumber = 1;
  ::google::protobuf::int32 pitch() const;
  void set_pitch(::google::protobuf::int32 value);

  // optional int32 Roll = 2;
  void clear_roll();
  static const int kRollFieldNumber = 2;
  ::google::protobuf::int32 roll() const;
  void set_roll(::google::protobuf::int32 value);

  // optional int32 Yaw = 3;
  void clear_yaw();
  static const int kYawFieldNumber = 3;
  ::google::protobuf::int32 yaw() const;
  void set_yaw(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerPosition.Rotation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 pitch_;
  ::google::protobuf::int32 roll_;
  ::google::protobuf::int32 yaw_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameModels_2eproto();
  friend void protobuf_AssignDesc_GameModels_2eproto();
  friend void protobuf_ShutdownFile_GameModels_2eproto();

  void InitAsDefaultInstance();
  static PlayerPosition_Rotation* default_instance_;
};
// -------------------------------------------------------------------

class PlayerPosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PlayerPosition) */ {
 public:
  PlayerPosition();
  virtual ~PlayerPosition();

  PlayerPosition(const PlayerPosition& from);

  inline PlayerPosition& operator=(const PlayerPosition& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerPosition& default_instance();

  void Swap(PlayerPosition* other);

  // implements Message ----------------------------------------------

  inline PlayerPosition* New() const { return New(NULL); }

  PlayerPosition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerPosition& from);
  void MergeFrom(const PlayerPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerPosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PlayerPosition_Location Location;
  typedef PlayerPosition_Rotation Rotation;

  // accessors -------------------------------------------------------

  // optional .PlayerPosition.Location loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  const ::PlayerPosition_Location& loc() const;
  ::PlayerPosition_Location* mutable_loc();
  ::PlayerPosition_Location* release_loc();
  void set_allocated_loc(::PlayerPosition_Location* loc);

  // optional .PlayerPosition.Rotation rot = 2;
  bool has_rot() const;
  void clear_rot();
  static const int kRotFieldNumber = 2;
  const ::PlayerPosition_Rotation& rot() const;
  ::PlayerPosition_Rotation* mutable_rot();
  ::PlayerPosition_Rotation* release_rot();
  void set_allocated_rot(::PlayerPosition_Rotation* rot);

  // optional string playerName = 3;
  void clear_playername();
  static const int kPlayerNameFieldNumber = 3;
  const ::std::string& playername() const;
  void set_playername(const ::std::string& value);
  void set_playername(const char* value);
  void set_playername(const char* value, size_t size);
  ::std::string* mutable_playername();
  ::std::string* release_playername();
  void set_allocated_playername(::std::string* playername);

  // optional int64 timeStamp = 4;
  void clear_timestamp();
  static const int kTimeStampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PlayerPosition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::PlayerPosition_Location* loc_;
  ::PlayerPosition_Rotation* rot_;
  ::google::protobuf::internal::ArenaStringPtr playername_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameModels_2eproto();
  friend void protobuf_AssignDesc_GameModels_2eproto();
  friend void protobuf_ShutdownFile_GameModels_2eproto();

  void InitAsDefaultInstance();
  static PlayerPosition* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Ping) */ {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  inline Ping* New() const { return New(NULL); }

  Ping* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Ping)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 time_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameModels_2eproto();
  friend void protobuf_AssignDesc_GameModels_2eproto();
  friend void protobuf_ShutdownFile_GameModels_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class Shot_Start : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Shot.Start) */ {
 public:
  Shot_Start();
  virtual ~Shot_Start();

  Shot_Start(const Shot_Start& from);

  inline Shot_Start& operator=(const Shot_Start& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Shot_Start& default_instance();

  void Swap(Shot_Start* other);

  // implements Message ----------------------------------------------

  inline Shot_Start* New() const { return New(NULL); }

  Shot_Start* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Shot_Start& from);
  void MergeFrom(const Shot_Start& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Shot_Start* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 X = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 Y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 Z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Shot.Start)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameModels_2eproto();
  friend void protobuf_AssignDesc_GameModels_2eproto();
  friend void protobuf_ShutdownFile_GameModels_2eproto();

  void InitAsDefaultInstance();
  static Shot_Start* default_instance_;
};
// -------------------------------------------------------------------

class Shot_End : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Shot.End) */ {
 public:
  Shot_End();
  virtual ~Shot_End();

  Shot_End(const Shot_End& from);

  inline Shot_End& operator=(const Shot_End& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Shot_End& default_instance();

  void Swap(Shot_End* other);

  // implements Message ----------------------------------------------

  inline Shot_End* New() const { return New(NULL); }

  Shot_End* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Shot_End& from);
  void MergeFrom(const Shot_End& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Shot_End* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 X = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 Y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 Z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Shot.End)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameModels_2eproto();
  friend void protobuf_AssignDesc_GameModels_2eproto();
  friend void protobuf_ShutdownFile_GameModels_2eproto();

  void InitAsDefaultInstance();
  static Shot_End* default_instance_;
};
// -------------------------------------------------------------------

class Shot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Shot) */ {
 public:
  Shot();
  virtual ~Shot();

  Shot(const Shot& from);

  inline Shot& operator=(const Shot& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Shot& default_instance();

  enum V1Case {
    kResultHitState = 8,
    V1_NOT_SET = 0,
  };

  void Swap(Shot* other);

  // implements Message ----------------------------------------------

  inline Shot* New() const { return New(NULL); }

  Shot* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Shot& from);
  void MergeFrom(const Shot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Shot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Shot_Start Start;
  typedef Shot_End End;

  // accessors -------------------------------------------------------

  // optional .Shot.Start start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  const ::Shot_Start& start() const;
  ::Shot_Start* mutable_start();
  ::Shot_Start* release_start();
  void set_allocated_start(::Shot_Start* start);

  // optional .Shot.End end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  const ::Shot_End& end() const;
  ::Shot_End* mutable_end();
  ::Shot_End* release_end();
  void set_allocated_end(::Shot_End* end);

  // optional .PlayerPosition playerPosition = 3;
  bool has_playerposition() const;
  void clear_playerposition();
  static const int kPlayerPositionFieldNumber = 3;
  const ::PlayerPosition& playerposition() const;
  ::PlayerPosition* mutable_playerposition();
  ::PlayerPosition* release_playerposition();
  void set_allocated_playerposition(::PlayerPosition* playerposition);

  // optional int64 timeStamp = 4;
  void clear_timestamp();
  static const int kTimeStampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // optional string requestFrom = 5;
  void clear_requestfrom();
  static const int kRequestFromFieldNumber = 5;
  const ::std::string& requestfrom() const;
  void set_requestfrom(const ::std::string& value);
  void set_requestfrom(const char* value);
  void set_requestfrom(const char* value, size_t size);
  ::std::string* mutable_requestfrom();
  ::std::string* release_requestfrom();
  void set_allocated_requestfrom(::std::string* requestfrom);

  // optional string requestTo = 6;
  void clear_requestto();
  static const int kRequestToFieldNumber = 6;
  const ::std::string& requestto() const;
  void set_requestto(const ::std::string& value);
  void set_requestto(const char* value);
  void set_requestto(const char* value, size_t size);
  ::std::string* mutable_requestto();
  ::std::string* release_requestto();
  void set_allocated_requestto(::std::string* requestto);

  // optional string roomOwner = 7;
  void clear_roomowner();
  static const int kRoomOwnerFieldNumber = 7;
  const ::std::string& roomowner() const;
  void set_roomowner(const ::std::string& value);
  void set_roomowner(const char* value);
  void set_roomowner(const char* value, size_t size);
  ::std::string* mutable_roomowner();
  ::std::string* release_roomowner();
  void set_allocated_roomowner(::std::string* roomowner);

  // optional bool result_hitState = 8;
  private:
  bool has_result_hitstate() const;
  public:
  void clear_result_hitstate();
  static const int kResultHitStateFieldNumber = 8;
  bool result_hitstate() const;
  void set_result_hitstate(bool value);

  // optional string result_bonename = 9;
  void clear_result_bonename();
  static const int kResultBonenameFieldNumber = 9;
  const ::std::string& result_bonename() const;
  void set_result_bonename(const ::std::string& value);
  void set_result_bonename(const char* value);
  void set_result_bonename(const char* value, size_t size);
  ::std::string* mutable_result_bonename();
  ::std::string* release_result_bonename();
  void set_allocated_result_bonename(::std::string* result_bonename);

  V1Case v1_case() const;
  // @@protoc_insertion_point(class_scope:Shot)
 private:
  inline void set_has_result_hitstate();

  inline bool has_v1() const;
  void clear_v1();
  inline void clear_has_v1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::Shot_Start* start_;
  ::Shot_End* end_;
  ::PlayerPosition* playerposition_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::internal::ArenaStringPtr requestfrom_;
  ::google::protobuf::internal::ArenaStringPtr requestto_;
  ::google::protobuf::internal::ArenaStringPtr roomowner_;
  ::google::protobuf::internal::ArenaStringPtr result_bonename_;
  union V1Union {
    V1Union() {}
    bool result_hitstate_;
  } v1_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_GameModels_2eproto();
  friend void protobuf_AssignDesc_GameModels_2eproto();
  friend void protobuf_ShutdownFile_GameModels_2eproto();

  void InitAsDefaultInstance();
  static Shot* default_instance_;
};
// -------------------------------------------------------------------

class GameData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameData) */ {
 public:
  GameData();
  virtual ~GameData();

  GameData(const GameData& from);

  inline GameData& operator=(const GameData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameData& default_instance();

  void Swap(GameData* other);

  // implements Message ----------------------------------------------

  inline GameData* New() const { return New(NULL); }

  GameData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameData& from);
  void MergeFrom(const GameData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .GameInitialState gameInitialState = 1;
  bool has_gameinitialstate() const;
  void clear_gameinitialstate();
  static const int kGameInitialStateFieldNumber = 1;
  const ::GameInitialState& gameinitialstate() const;
  ::GameInitialState* mutable_gameinitialstate();
  ::GameInitialState* release_gameinitialstate();
  void set_allocated_gameinitialstate(::GameInitialState* gameinitialstate);

  // optional .PlayerPosition playerPosition = 2;
  bool has_playerposition() const;
  void clear_playerposition();
  static const int kPlayerPositionFieldNumber = 2;
  const ::PlayerPosition& playerposition() const;
  ::PlayerPosition* mutable_playerposition();
  ::PlayerPosition* release_playerposition();
  void set_allocated_playerposition(::PlayerPosition* playerposition);

  // optional .Ping ping = 3;
  bool has_ping() const;
  void clear_ping();
  static const int kPingFieldNumber = 3;
  const ::Ping& ping() const;
  ::Ping* mutable_ping();
  ::Ping* release_ping();
  void set_allocated_ping(::Ping* ping);

  // optional .Shot shot = 4;
  bool has_shot() const;
  void clear_shot();
  static const int kShotFieldNumber = 4;
  const ::Shot& shot() const;
  ::Shot* mutable_shot();
  ::Shot* release_shot();
  void set_allocated_shot(::Shot* shot);

  // @@protoc_insertion_point(class_scope:GameData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::GameInitialState* gameinitialstate_;
  ::PlayerPosition* playerposition_;
  ::Ping* ping_;
  ::Shot* shot_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameModels_2eproto();
  friend void protobuf_AssignDesc_GameModels_2eproto();
  friend void protobuf_ShutdownFile_GameModels_2eproto();

  void InitAsDefaultInstance();
  static GameData* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GameInitialState

// optional bool startGame = 1;
inline void GameInitialState::clear_startgame() {
  startgame_ = false;
}
inline bool GameInitialState::startgame() const {
  // @@protoc_insertion_point(field_get:GameInitialState.startGame)
  return startgame_;
}
inline void GameInitialState::set_startgame(bool value) {
  
  startgame_ = value;
  // @@protoc_insertion_point(field_set:GameInitialState.startGame)
}

// repeated .Player player = 2;
inline int GameInitialState::player_size() const {
  return player_.size();
}
inline void GameInitialState::clear_player() {
  player_.Clear();
}
inline const ::Player& GameInitialState::player(int index) const {
  // @@protoc_insertion_point(field_get:GameInitialState.player)
  return player_.Get(index);
}
inline ::Player* GameInitialState::mutable_player(int index) {
  // @@protoc_insertion_point(field_mutable:GameInitialState.player)
  return player_.Mutable(index);
}
inline ::Player* GameInitialState::add_player() {
  // @@protoc_insertion_point(field_add:GameInitialState.player)
  return player_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Player >*
GameInitialState::mutable_player() {
  // @@protoc_insertion_point(field_mutable_list:GameInitialState.player)
  return &player_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Player >&
GameInitialState::player() const {
  // @@protoc_insertion_point(field_list:GameInitialState.player)
  return player_;
}

// -------------------------------------------------------------------

// Player

// optional string player_name = 1;
inline void Player::clear_player_name() {
  player_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Player::player_name() const {
  // @@protoc_insertion_point(field_get:Player.player_name)
  return player_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_player_name(const ::std::string& value) {
  
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Player.player_name)
}
inline void Player::set_player_name(const char* value) {
  
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Player.player_name)
}
inline void Player::set_player_name(const char* value, size_t size) {
  
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Player.player_name)
}
inline ::std::string* Player::mutable_player_name() {
  
  // @@protoc_insertion_point(field_mutable:Player.player_name)
  return player_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_player_name() {
  // @@protoc_insertion_point(field_release:Player.player_name)
  
  return player_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_player_name(::std::string* player_name) {
  if (player_name != NULL) {
    
  } else {
    
  }
  player_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), player_name);
  // @@protoc_insertion_point(field_set_allocated:Player.player_name)
}

// optional string team = 2;
inline void Player::clear_team() {
  team_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Player::team() const {
  // @@protoc_insertion_point(field_get:Player.team)
  return team_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_team(const ::std::string& value) {
  
  team_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Player.team)
}
inline void Player::set_team(const char* value) {
  
  team_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Player.team)
}
inline void Player::set_team(const char* value, size_t size) {
  
  team_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Player.team)
}
inline ::std::string* Player::mutable_team() {
  
  // @@protoc_insertion_point(field_mutable:Player.team)
  return team_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_team() {
  // @@protoc_insertion_point(field_release:Player.team)
  
  return team_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_team(::std::string* team) {
  if (team != NULL) {
    
  } else {
    
  }
  team_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team);
  // @@protoc_insertion_point(field_set_allocated:Player.team)
}

// optional int32 health = 3;
inline void Player::clear_health() {
  health_ = 0;
}
inline ::google::protobuf::int32 Player::health() const {
  // @@protoc_insertion_point(field_get:Player.health)
  return health_;
}
inline void Player::set_health(::google::protobuf::int32 value) {
  
  health_ = value;
  // @@protoc_insertion_point(field_set:Player.health)
}

// optional .PlayerPosition playerPosition = 4;
inline bool Player::has_playerposition() const {
  return !_is_default_instance_ && playerposition_ != NULL;
}
inline void Player::clear_playerposition() {
  if (GetArenaNoVirtual() == NULL && playerposition_ != NULL) delete playerposition_;
  playerposition_ = NULL;
}
inline const ::PlayerPosition& Player::playerposition() const {
  // @@protoc_insertion_point(field_get:Player.playerPosition)
  return playerposition_ != NULL ? *playerposition_ : *default_instance_->playerposition_;
}
inline ::PlayerPosition* Player::mutable_playerposition() {
  
  if (playerposition_ == NULL) {
    playerposition_ = new ::PlayerPosition;
  }
  // @@protoc_insertion_point(field_mutable:Player.playerPosition)
  return playerposition_;
}
inline ::PlayerPosition* Player::release_playerposition() {
  // @@protoc_insertion_point(field_release:Player.playerPosition)
  
  ::PlayerPosition* temp = playerposition_;
  playerposition_ = NULL;
  return temp;
}
inline void Player::set_allocated_playerposition(::PlayerPosition* playerposition) {
  delete playerposition_;
  playerposition_ = playerposition;
  if (playerposition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Player.playerPosition)
}

// -------------------------------------------------------------------

// PlayerPosition_Location

// optional int32 X = 1;
inline void PlayerPosition_Location::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 PlayerPosition_Location::x() const {
  // @@protoc_insertion_point(field_get:PlayerPosition.Location.X)
  return x_;
}
inline void PlayerPosition_Location::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:PlayerPosition.Location.X)
}

// optional int32 Y = 2;
inline void PlayerPosition_Location::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 PlayerPosition_Location::y() const {
  // @@protoc_insertion_point(field_get:PlayerPosition.Location.Y)
  return y_;
}
inline void PlayerPosition_Location::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:PlayerPosition.Location.Y)
}

// optional int32 Z = 3;
inline void PlayerPosition_Location::clear_z() {
  z_ = 0;
}
inline ::google::protobuf::int32 PlayerPosition_Location::z() const {
  // @@protoc_insertion_point(field_get:PlayerPosition.Location.Z)
  return z_;
}
inline void PlayerPosition_Location::set_z(::google::protobuf::int32 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:PlayerPosition.Location.Z)
}

// -------------------------------------------------------------------

// PlayerPosition_Rotation

// optional int32 Pitch = 1;
inline void PlayerPosition_Rotation::clear_pitch() {
  pitch_ = 0;
}
inline ::google::protobuf::int32 PlayerPosition_Rotation::pitch() const {
  // @@protoc_insertion_point(field_get:PlayerPosition.Rotation.Pitch)
  return pitch_;
}
inline void PlayerPosition_Rotation::set_pitch(::google::protobuf::int32 value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:PlayerPosition.Rotation.Pitch)
}

// optional int32 Roll = 2;
inline void PlayerPosition_Rotation::clear_roll() {
  roll_ = 0;
}
inline ::google::protobuf::int32 PlayerPosition_Rotation::roll() const {
  // @@protoc_insertion_point(field_get:PlayerPosition.Rotation.Roll)
  return roll_;
}
inline void PlayerPosition_Rotation::set_roll(::google::protobuf::int32 value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:PlayerPosition.Rotation.Roll)
}

// optional int32 Yaw = 3;
inline void PlayerPosition_Rotation::clear_yaw() {
  yaw_ = 0;
}
inline ::google::protobuf::int32 PlayerPosition_Rotation::yaw() const {
  // @@protoc_insertion_point(field_get:PlayerPosition.Rotation.Yaw)
  return yaw_;
}
inline void PlayerPosition_Rotation::set_yaw(::google::protobuf::int32 value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:PlayerPosition.Rotation.Yaw)
}

// -------------------------------------------------------------------

// PlayerPosition

// optional .PlayerPosition.Location loc = 1;
inline bool PlayerPosition::has_loc() const {
  return !_is_default_instance_ && loc_ != NULL;
}
inline void PlayerPosition::clear_loc() {
  if (GetArenaNoVirtual() == NULL && loc_ != NULL) delete loc_;
  loc_ = NULL;
}
inline const ::PlayerPosition_Location& PlayerPosition::loc() const {
  // @@protoc_insertion_point(field_get:PlayerPosition.loc)
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
}
inline ::PlayerPosition_Location* PlayerPosition::mutable_loc() {
  
  if (loc_ == NULL) {
    loc_ = new ::PlayerPosition_Location;
  }
  // @@protoc_insertion_point(field_mutable:PlayerPosition.loc)
  return loc_;
}
inline ::PlayerPosition_Location* PlayerPosition::release_loc() {
  // @@protoc_insertion_point(field_release:PlayerPosition.loc)
  
  ::PlayerPosition_Location* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void PlayerPosition::set_allocated_loc(::PlayerPosition_Location* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PlayerPosition.loc)
}

// optional .PlayerPosition.Rotation rot = 2;
inline bool PlayerPosition::has_rot() const {
  return !_is_default_instance_ && rot_ != NULL;
}
inline void PlayerPosition::clear_rot() {
  if (GetArenaNoVirtual() == NULL && rot_ != NULL) delete rot_;
  rot_ = NULL;
}
inline const ::PlayerPosition_Rotation& PlayerPosition::rot() const {
  // @@protoc_insertion_point(field_get:PlayerPosition.rot)
  return rot_ != NULL ? *rot_ : *default_instance_->rot_;
}
inline ::PlayerPosition_Rotation* PlayerPosition::mutable_rot() {
  
  if (rot_ == NULL) {
    rot_ = new ::PlayerPosition_Rotation;
  }
  // @@protoc_insertion_point(field_mutable:PlayerPosition.rot)
  return rot_;
}
inline ::PlayerPosition_Rotation* PlayerPosition::release_rot() {
  // @@protoc_insertion_point(field_release:PlayerPosition.rot)
  
  ::PlayerPosition_Rotation* temp = rot_;
  rot_ = NULL;
  return temp;
}
inline void PlayerPosition::set_allocated_rot(::PlayerPosition_Rotation* rot) {
  delete rot_;
  rot_ = rot;
  if (rot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PlayerPosition.rot)
}

// optional string playerName = 3;
inline void PlayerPosition::clear_playername() {
  playername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerPosition::playername() const {
  // @@protoc_insertion_point(field_get:PlayerPosition.playerName)
  return playername_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerPosition::set_playername(const ::std::string& value) {
  
  playername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PlayerPosition.playerName)
}
inline void PlayerPosition::set_playername(const char* value) {
  
  playername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PlayerPosition.playerName)
}
inline void PlayerPosition::set_playername(const char* value, size_t size) {
  
  playername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PlayerPosition.playerName)
}
inline ::std::string* PlayerPosition::mutable_playername() {
  
  // @@protoc_insertion_point(field_mutable:PlayerPosition.playerName)
  return playername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerPosition::release_playername() {
  // @@protoc_insertion_point(field_release:PlayerPosition.playerName)
  
  return playername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerPosition::set_allocated_playername(::std::string* playername) {
  if (playername != NULL) {
    
  } else {
    
  }
  playername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), playername);
  // @@protoc_insertion_point(field_set_allocated:PlayerPosition.playerName)
}

// optional int64 timeStamp = 4;
inline void PlayerPosition::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PlayerPosition::timestamp() const {
  // @@protoc_insertion_point(field_get:PlayerPosition.timeStamp)
  return timestamp_;
}
inline void PlayerPosition::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:PlayerPosition.timeStamp)
}

// -------------------------------------------------------------------

// Ping

// optional int64 time = 1;
inline void Ping::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Ping::time() const {
  // @@protoc_insertion_point(field_get:Ping.time)
  return time_;
}
inline void Ping::set_time(::google::protobuf::int64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:Ping.time)
}

// -------------------------------------------------------------------

// Shot_Start

// optional int32 X = 1;
inline void Shot_Start::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Shot_Start::x() const {
  // @@protoc_insertion_point(field_get:Shot.Start.X)
  return x_;
}
inline void Shot_Start::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Shot.Start.X)
}

// optional int32 Y = 2;
inline void Shot_Start::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Shot_Start::y() const {
  // @@protoc_insertion_point(field_get:Shot.Start.Y)
  return y_;
}
inline void Shot_Start::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Shot.Start.Y)
}

// optional int32 Z = 3;
inline void Shot_Start::clear_z() {
  z_ = 0;
}
inline ::google::protobuf::int32 Shot_Start::z() const {
  // @@protoc_insertion_point(field_get:Shot.Start.Z)
  return z_;
}
inline void Shot_Start::set_z(::google::protobuf::int32 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Shot.Start.Z)
}

// -------------------------------------------------------------------

// Shot_End

// optional int32 X = 1;
inline void Shot_End::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Shot_End::x() const {
  // @@protoc_insertion_point(field_get:Shot.End.X)
  return x_;
}
inline void Shot_End::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Shot.End.X)
}

// optional int32 Y = 2;
inline void Shot_End::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Shot_End::y() const {
  // @@protoc_insertion_point(field_get:Shot.End.Y)
  return y_;
}
inline void Shot_End::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Shot.End.Y)
}

// optional int32 Z = 3;
inline void Shot_End::clear_z() {
  z_ = 0;
}
inline ::google::protobuf::int32 Shot_End::z() const {
  // @@protoc_insertion_point(field_get:Shot.End.Z)
  return z_;
}
inline void Shot_End::set_z(::google::protobuf::int32 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Shot.End.Z)
}

// -------------------------------------------------------------------

// Shot

// optional .Shot.Start start = 1;
inline bool Shot::has_start() const {
  return !_is_default_instance_ && start_ != NULL;
}
inline void Shot::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) delete start_;
  start_ = NULL;
}
inline const ::Shot_Start& Shot::start() const {
  // @@protoc_insertion_point(field_get:Shot.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::Shot_Start* Shot::mutable_start() {
  
  if (start_ == NULL) {
    start_ = new ::Shot_Start;
  }
  // @@protoc_insertion_point(field_mutable:Shot.start)
  return start_;
}
inline ::Shot_Start* Shot::release_start() {
  // @@protoc_insertion_point(field_release:Shot.start)
  
  ::Shot_Start* temp = start_;
  start_ = NULL;
  return temp;
}
inline void Shot::set_allocated_start(::Shot_Start* start) {
  delete start_;
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Shot.start)
}

// optional .Shot.End end = 2;
inline bool Shot::has_end() const {
  return !_is_default_instance_ && end_ != NULL;
}
inline void Shot::clear_end() {
  if (GetArenaNoVirtual() == NULL && end_ != NULL) delete end_;
  end_ = NULL;
}
inline const ::Shot_End& Shot::end() const {
  // @@protoc_insertion_point(field_get:Shot.end)
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::Shot_End* Shot::mutable_end() {
  
  if (end_ == NULL) {
    end_ = new ::Shot_End;
  }
  // @@protoc_insertion_point(field_mutable:Shot.end)
  return end_;
}
inline ::Shot_End* Shot::release_end() {
  // @@protoc_insertion_point(field_release:Shot.end)
  
  ::Shot_End* temp = end_;
  end_ = NULL;
  return temp;
}
inline void Shot::set_allocated_end(::Shot_End* end) {
  delete end_;
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Shot.end)
}

// optional .PlayerPosition playerPosition = 3;
inline bool Shot::has_playerposition() const {
  return !_is_default_instance_ && playerposition_ != NULL;
}
inline void Shot::clear_playerposition() {
  if (GetArenaNoVirtual() == NULL && playerposition_ != NULL) delete playerposition_;
  playerposition_ = NULL;
}
inline const ::PlayerPosition& Shot::playerposition() const {
  // @@protoc_insertion_point(field_get:Shot.playerPosition)
  return playerposition_ != NULL ? *playerposition_ : *default_instance_->playerposition_;
}
inline ::PlayerPosition* Shot::mutable_playerposition() {
  
  if (playerposition_ == NULL) {
    playerposition_ = new ::PlayerPosition;
  }
  // @@protoc_insertion_point(field_mutable:Shot.playerPosition)
  return playerposition_;
}
inline ::PlayerPosition* Shot::release_playerposition() {
  // @@protoc_insertion_point(field_release:Shot.playerPosition)
  
  ::PlayerPosition* temp = playerposition_;
  playerposition_ = NULL;
  return temp;
}
inline void Shot::set_allocated_playerposition(::PlayerPosition* playerposition) {
  delete playerposition_;
  playerposition_ = playerposition;
  if (playerposition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Shot.playerPosition)
}

// optional int64 timeStamp = 4;
inline void Shot::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Shot::timestamp() const {
  // @@protoc_insertion_point(field_get:Shot.timeStamp)
  return timestamp_;
}
inline void Shot::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Shot.timeStamp)
}

// optional string requestFrom = 5;
inline void Shot::clear_requestfrom() {
  requestfrom_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Shot::requestfrom() const {
  // @@protoc_insertion_point(field_get:Shot.requestFrom)
  return requestfrom_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Shot::set_requestfrom(const ::std::string& value) {
  
  requestfrom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Shot.requestFrom)
}
inline void Shot::set_requestfrom(const char* value) {
  
  requestfrom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Shot.requestFrom)
}
inline void Shot::set_requestfrom(const char* value, size_t size) {
  
  requestfrom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Shot.requestFrom)
}
inline ::std::string* Shot::mutable_requestfrom() {
  
  // @@protoc_insertion_point(field_mutable:Shot.requestFrom)
  return requestfrom_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Shot::release_requestfrom() {
  // @@protoc_insertion_point(field_release:Shot.requestFrom)
  
  return requestfrom_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Shot::set_allocated_requestfrom(::std::string* requestfrom) {
  if (requestfrom != NULL) {
    
  } else {
    
  }
  requestfrom_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requestfrom);
  // @@protoc_insertion_point(field_set_allocated:Shot.requestFrom)
}

// optional string requestTo = 6;
inline void Shot::clear_requestto() {
  requestto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Shot::requestto() const {
  // @@protoc_insertion_point(field_get:Shot.requestTo)
  return requestto_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Shot::set_requestto(const ::std::string& value) {
  
  requestto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Shot.requestTo)
}
inline void Shot::set_requestto(const char* value) {
  
  requestto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Shot.requestTo)
}
inline void Shot::set_requestto(const char* value, size_t size) {
  
  requestto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Shot.requestTo)
}
inline ::std::string* Shot::mutable_requestto() {
  
  // @@protoc_insertion_point(field_mutable:Shot.requestTo)
  return requestto_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Shot::release_requestto() {
  // @@protoc_insertion_point(field_release:Shot.requestTo)
  
  return requestto_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Shot::set_allocated_requestto(::std::string* requestto) {
  if (requestto != NULL) {
    
  } else {
    
  }
  requestto_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requestto);
  // @@protoc_insertion_point(field_set_allocated:Shot.requestTo)
}

// optional string roomOwner = 7;
inline void Shot::clear_roomowner() {
  roomowner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Shot::roomowner() const {
  // @@protoc_insertion_point(field_get:Shot.roomOwner)
  return roomowner_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Shot::set_roomowner(const ::std::string& value) {
  
  roomowner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Shot.roomOwner)
}
inline void Shot::set_roomowner(const char* value) {
  
  roomowner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Shot.roomOwner)
}
inline void Shot::set_roomowner(const char* value, size_t size) {
  
  roomowner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Shot.roomOwner)
}
inline ::std::string* Shot::mutable_roomowner() {
  
  // @@protoc_insertion_point(field_mutable:Shot.roomOwner)
  return roomowner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Shot::release_roomowner() {
  // @@protoc_insertion_point(field_release:Shot.roomOwner)
  
  return roomowner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Shot::set_allocated_roomowner(::std::string* roomowner) {
  if (roomowner != NULL) {
    
  } else {
    
  }
  roomowner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomowner);
  // @@protoc_insertion_point(field_set_allocated:Shot.roomOwner)
}

// optional bool result_hitState = 8;
inline bool Shot::has_result_hitstate() const {
  return v1_case() == kResultHitState;
}
inline void Shot::set_has_result_hitstate() {
  _oneof_case_[0] = kResultHitState;
}
inline void Shot::clear_result_hitstate() {
  if (has_result_hitstate()) {
    v1_.result_hitstate_ = false;
    clear_has_v1();
  }
}
inline bool Shot::result_hitstate() const {
  // @@protoc_insertion_point(field_get:Shot.result_hitState)
  if (has_result_hitstate()) {
    return v1_.result_hitstate_;
  }
  return false;
}
inline void Shot::set_result_hitstate(bool value) {
  if (!has_result_hitstate()) {
    clear_v1();
    set_has_result_hitstate();
  }
  v1_.result_hitstate_ = value;
  // @@protoc_insertion_point(field_set:Shot.result_hitState)
}

// optional string result_bonename = 9;
inline void Shot::clear_result_bonename() {
  result_bonename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Shot::result_bonename() const {
  // @@protoc_insertion_point(field_get:Shot.result_bonename)
  return result_bonename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Shot::set_result_bonename(const ::std::string& value) {
  
  result_bonename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Shot.result_bonename)
}
inline void Shot::set_result_bonename(const char* value) {
  
  result_bonename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Shot.result_bonename)
}
inline void Shot::set_result_bonename(const char* value, size_t size) {
  
  result_bonename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Shot.result_bonename)
}
inline ::std::string* Shot::mutable_result_bonename() {
  
  // @@protoc_insertion_point(field_mutable:Shot.result_bonename)
  return result_bonename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Shot::release_result_bonename() {
  // @@protoc_insertion_point(field_release:Shot.result_bonename)
  
  return result_bonename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Shot::set_allocated_result_bonename(::std::string* result_bonename) {
  if (result_bonename != NULL) {
    
  } else {
    
  }
  result_bonename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), result_bonename);
  // @@protoc_insertion_point(field_set_allocated:Shot.result_bonename)
}

inline bool Shot::has_v1() const {
  return v1_case() != V1_NOT_SET;
}
inline void Shot::clear_has_v1() {
  _oneof_case_[0] = V1_NOT_SET;
}
inline Shot::V1Case Shot::v1_case() const {
  return Shot::V1Case(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GameData

// optional .GameInitialState gameInitialState = 1;
inline bool GameData::has_gameinitialstate() const {
  return !_is_default_instance_ && gameinitialstate_ != NULL;
}
inline void GameData::clear_gameinitialstate() {
  if (GetArenaNoVirtual() == NULL && gameinitialstate_ != NULL) delete gameinitialstate_;
  gameinitialstate_ = NULL;
}
inline const ::GameInitialState& GameData::gameinitialstate() const {
  // @@protoc_insertion_point(field_get:GameData.gameInitialState)
  return gameinitialstate_ != NULL ? *gameinitialstate_ : *default_instance_->gameinitialstate_;
}
inline ::GameInitialState* GameData::mutable_gameinitialstate() {
  
  if (gameinitialstate_ == NULL) {
    gameinitialstate_ = new ::GameInitialState;
  }
  // @@protoc_insertion_point(field_mutable:GameData.gameInitialState)
  return gameinitialstate_;
}
inline ::GameInitialState* GameData::release_gameinitialstate() {
  // @@protoc_insertion_point(field_release:GameData.gameInitialState)
  
  ::GameInitialState* temp = gameinitialstate_;
  gameinitialstate_ = NULL;
  return temp;
}
inline void GameData::set_allocated_gameinitialstate(::GameInitialState* gameinitialstate) {
  delete gameinitialstate_;
  gameinitialstate_ = gameinitialstate;
  if (gameinitialstate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:GameData.gameInitialState)
}

// optional .PlayerPosition playerPosition = 2;
inline bool GameData::has_playerposition() const {
  return !_is_default_instance_ && playerposition_ != NULL;
}
inline void GameData::clear_playerposition() {
  if (GetArenaNoVirtual() == NULL && playerposition_ != NULL) delete playerposition_;
  playerposition_ = NULL;
}
inline const ::PlayerPosition& GameData::playerposition() const {
  // @@protoc_insertion_point(field_get:GameData.playerPosition)
  return playerposition_ != NULL ? *playerposition_ : *default_instance_->playerposition_;
}
inline ::PlayerPosition* GameData::mutable_playerposition() {
  
  if (playerposition_ == NULL) {
    playerposition_ = new ::PlayerPosition;
  }
  // @@protoc_insertion_point(field_mutable:GameData.playerPosition)
  return playerposition_;
}
inline ::PlayerPosition* GameData::release_playerposition() {
  // @@protoc_insertion_point(field_release:GameData.playerPosition)
  
  ::PlayerPosition* temp = playerposition_;
  playerposition_ = NULL;
  return temp;
}
inline void GameData::set_allocated_playerposition(::PlayerPosition* playerposition) {
  delete playerposition_;
  playerposition_ = playerposition;
  if (playerposition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:GameData.playerPosition)
}

// optional .Ping ping = 3;
inline bool GameData::has_ping() const {
  return !_is_default_instance_ && ping_ != NULL;
}
inline void GameData::clear_ping() {
  if (GetArenaNoVirtual() == NULL && ping_ != NULL) delete ping_;
  ping_ = NULL;
}
inline const ::Ping& GameData::ping() const {
  // @@protoc_insertion_point(field_get:GameData.ping)
  return ping_ != NULL ? *ping_ : *default_instance_->ping_;
}
inline ::Ping* GameData::mutable_ping() {
  
  if (ping_ == NULL) {
    ping_ = new ::Ping;
  }
  // @@protoc_insertion_point(field_mutable:GameData.ping)
  return ping_;
}
inline ::Ping* GameData::release_ping() {
  // @@protoc_insertion_point(field_release:GameData.ping)
  
  ::Ping* temp = ping_;
  ping_ = NULL;
  return temp;
}
inline void GameData::set_allocated_ping(::Ping* ping) {
  delete ping_;
  ping_ = ping;
  if (ping) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:GameData.ping)
}

// optional .Shot shot = 4;
inline bool GameData::has_shot() const {
  return !_is_default_instance_ && shot_ != NULL;
}
inline void GameData::clear_shot() {
  if (GetArenaNoVirtual() == NULL && shot_ != NULL) delete shot_;
  shot_ = NULL;
}
inline const ::Shot& GameData::shot() const {
  // @@protoc_insertion_point(field_get:GameData.shot)
  return shot_ != NULL ? *shot_ : *default_instance_->shot_;
}
inline ::Shot* GameData::mutable_shot() {
  
  if (shot_ == NULL) {
    shot_ = new ::Shot;
  }
  // @@protoc_insertion_point(field_mutable:GameData.shot)
  return shot_;
}
inline ::Shot* GameData::release_shot() {
  // @@protoc_insertion_point(field_release:GameData.shot)
  
  ::Shot* temp = shot_;
  shot_ = NULL;
  return temp;
}
inline void GameData::set_allocated_shot(::Shot* shot) {
  delete shot_;
  shot_ = shot;
  if (shot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:GameData.shot)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GameModels_2eproto__INCLUDED
